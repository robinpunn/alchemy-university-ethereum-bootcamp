# [Foundry Full Course](https://github.com/Cyfrin/foundry-full-course-f23) 

---

### Table of Contents

<details>

<summary> Lesson 1: Blockchain Basics </summary>

1. [What is a blockchain?](#what-is-a-blockchain)
2. [The Purpose of Smart Contracts](#the-purpose-of-smart-contracts)
3. [Other Blockchain Benefits](#other-blockchain-benefits)
4. [What have Smart Contracts done so far?](#what-have-smart-contracts-done-so-far)
5. [Gas 1: Introduction to Gas](#gas-1-introduction-to-gas)
6. [How do Blockchains work?](#how-do-blockchains-work)
7. [Signing Transactions](#signing-transactions)
8. [Gas II](#gas-ii)
9. [Gass II Summary](#gas-ii-summary)
10. [High Level Blockchain Fundamentals](#high-level-blockchain-fundamentals)

</details>

<details>

<summary> Lesson 2: Welcome to Remix </summary>

1. [Introduction](#introduction)
2. [Setting Up Your First Contract](#setting-up-your-first-contract)
3. [Basic Solidity: Types](#basic-solidity-types)
4. [Basic Solidity: Functions](#basic-solidity-functions)
5. [Basic Solidity: Structs and Arrays](#basic-solidity-structs-and-arrays)
6. [Basic Solidity: Compiler Errors and Warnings](#basic-solidity-compiler-errors-and-warnings)
7. [Memory, Storage, Calldata](#memory-storage-calldata)
8. [Basic Solidity: Mappings](#basic-solidity-mappings)
9. [Deploying Your First Smart Contract](#deploying-your-first-smart-contract)
10. [The EVM and Recap](#the-evm-and-recap)

</details>

<details>

<summary> Lesson 3: Storage Factory </summary>

1. [Introduction](#introduction)
2. [Importing Contracts into Other Contracts](#basic-solidity-importing-contracts-into-other-contracts)
3. [Interacting with other Contracts](#basic-solidity-interacting-with-other-contracts)
4. [Inheritance and Overrides](#basic-solidity-inheritance-and-overrides)
5. [Summary](#summary)
</details>

<details>

<summary> Lesson 4: Remix Fund Me </summary>

1. [Sending Eth through a function](#sending-eth-through-a-function)
2. [Getting real world price data (Chainlink)](#getting-real-world-price-data-chainlink)
3. [Interfaces](#interfaces)
4. [Importing from NPM/GitHub](#importing-from-npm--github)
5. [Getting Prices from Chainlink](#getting-prices-from-chainlink)
6. [More Solidity Math](#more-solidity-math)
7. [msg.sender](#msgsender)
8. [Library](#library)
9. [SafeMath](#safemath)
10. [For Loop](#for-loop)
11. [Resetting an Array](#resetting-an-array)
12. [Transfer, Send, and Call](#transfer-send-and-call)
13. [Constructor](#constructor)
14. [Modifiers](#modifiers)
15. [Testnet Demo](#testnet-demo)
16. [Immutable and Constant](#immutable--constant)
17. [Custom Errors](#custom-errors)
18. [Receive and Fallback Function](#receive-and-fallback-function)

</details>

<details>

<summary> Lessong 5: AI Prompting and Forums </summary>

1. [7 Tips for this course](#7-tips-for-this-course)
2. [Formatting a Question](#formatting-a-question)
3. [Speedrun Ethereum](#speedrunethereum)

</details>

<details>

<summary> Lesson 6: Foundry Simple Storage </summary>

1. [Introduction](#introduction-2)
2. [Installation and Setup](#installation--setup)
3. [Local Development Introduction](#local-development-introduction)
4. [Foundry Install](#foundry-install)
5. [VSCode Setup II](#vscode-setup-ii)
6. [Foundry Setup](#foundry-setup)
7. [Formatting Solidity in VSCode](#formatting-solidity-in-vscode)
8. [Compiling in Foundry](#compiling-in-foundry)
9. [Compiling in Foundry](#compiling-in-foundry)
10. [Deploying to a local chain (Anvil or Ganache)](#deploying-to-a-local-chain-anvil-or-ganache)
11. [Adding Another Network on Metamask](#adding-another-network-on-metamask)
12. [Deploying to a local chain (Forge Create)](#deploying-to-a-local-chain-forge-create)
13. [Deploying to a local chain (Forge Script)](#deploying-to-a-local-chain-forge-script)
14. [What is a transaction?](#what-is-a-transaction)
15. [Private Keys](#private-keys)
16. [ThirdWeb Deploy](#thirdweb-deploy)
17. [Private Key Summary](#private-key-summary)
18. [Cast Send](#cast-send)
19. [Deploying to a testnet or mainnet](#deploying-to-a-testnet-or-mainnet)
20. [Verifying a contract the manual way](#verifying-a-contract-the-manual-way)
21. [Cleaning up the Project](#cleaning-up-the-project)
22. [Alchemy and the mempool](#alchemy-and-the-mempool)
23. [Summary](#summary)

</details>

<details>

<summary> Lesson 7: Foundry Fund Me </summary>

1. [Setup](#setup)
2. [Testing Introduction](#testing-introduction)
3. [Setup Continued](#setup-continued)
4. [Tests](#tests)
5. [Debugging Tests I](#debugging-tests-i)
6. [Advanced Deploy Script I](#advanced-deploy-script-i)
7. [Forked Test](#forked-tests)
8. [Refactoring I Testing Deploy Scripts](#refactoring-i-testing-deploy-scripts)
9. [Refactoring II Helper Config](#refactoring-ii-helper-config)
10. [Refactoring III Mocks](#refactoring-iii-mocks)
11. [Magic Numbers](#magic-numbers)
12. [Refactoring III Mocking](#refactoring-iii-mocking)
13. [More Cheatcodes](#more-cheatcodes)
14. [More Coverage](#more-coverage)
15. [Chisel](#chisel)
16. [Cheaper Withdraw](#cheaper-withdraw)
17. [Storage](#storage)
18. [Cheaper Withdraw II](#cheaper-withdraw-ii)
19. [Interactions.s.sol](#interactionsssol)
20. [Makefile](#makefile)
21. [Push to GitHub](#push-to-github)

</details>

<details>

<summary> Lesson 8: HTML Fund Me </summary>

1. [How Metamask works](#how-metamask-works-with-your-browser)
2. [Introduction to function selectors](#introduction-to-function-selectors)

</details>

<details>

<summary> Lesson 9: Foundry Smart Contract Lottery </summary>

1. [Raffle.sol Setup](#rafflesol-setup)
2. [Solidity Contract Layout](#solidity-contract-layout)
3. [Custom Errors](#custom-errors)
4. [Events](#events)
5. [block.timestamp](#blocktimestamp)
6. [Chainlink VRF](#chainlink-vrf)
7. [Implementing Chainlink VRG](#implementing-chainlink-vrg)
8. [Chainlink Summary](#chainlink-summary)
9. [Modulo](#modulo)
10. [Enum](#enum)
11. [Resetting an Array](#resetting-an-array)
12. [CEI (Checks, Effects, Interactions)](#cei-checks-effects-interactions)
13. [Chainlink Automation](#chainlink-automation)
14. [Test and Deploy Script Setup](#test-and-deploy-script-setup)
15. [VRF Mocks](#vrf-mocks)
16. [Tests and Deploy Scripts Continued](#tests-and-deploy-scripts-continued)
17. [Lots of Tests](#lots-of-tests)
18. [Testing Events in Foundry](#testing-events-in-foundry)
19. [`vm.roll`and `vm.warp`](#vmroll-and-vmwarp)
20. [Create Subscription Script](#create-subscription-script)
21. [Create Subscription from the UI](#create-subscription-from-the-ui)
22. [Fund Subscription Script](#fund-subscription-script)
23. [Add Consumer Script](#add-consumer-script)
24. [CheckUpkeep Tests](#checkupkeep-tests)
25. [PerformUpkeep Tests](#performupkeep-tests)
26. [Getting Event Data Into Foundry Scripts](#getting-event-data-into-foundry-scripts)
27. [Intro to Fuzz Tess](#intro-to-fuzz-tests)
28. [One Big Test](#one-big-test)
29. [Passing the private key to vm.startBroadcast](#passing-the-private-key-to-vmstartbroadcast)
30. [Integrations Test](#integrations-test)
31. [Testnet Demo Makefile Setup](#testnet-demo-makefile-setup)
32. [Testnet Demo](#testnet-demo)
33. [`console.log` debugging](#consolelog-debugging)
34. [`forge test --debug`](#forge-test---debug)

</details>

<details>

<summary> Lesson 10: Foundry ERC20 </summary>

1. [What is an ERC20? What is an EIP?](#what-is-an-erc20-what-is-an-eip)
2. [What is an ERC20](#what-is-an-erc20)
3. [Manual Token](#manual-token)
4. [ERC20 Token OpenZeppelin](#erc20-token-openzeppelin)
5. [Deploy Script](#deploy-script)
6. [AI Tests](#ai-tests)

</details>

<details>

<summary> Lesson 11: Foundry NFTs </summary>

1. [What is an NFT](#what-is-an-nft)
2. [Foundry Setup](#foundry-setup-1)
3. [IPFS](#ipfs)
4. [Using IPFS](#using-ipfs)
5. [BasicNFT Deploy Script](#basicnft-deploy-script)
6. [BasicNFT Tests](#basicnft-tests)
7. [BasicNFT Interactions](#basicnft-interactions)
8. [BasicNFT Testnet Demo](#basicnft-testnet-demo)
9. [The issue with IPFS and HTTPS TokenURI NFTs](#the-issue-with-ipfs-and-https-tokenuri-nfts)
10. [What is an SVG](#what-is-an-svg)
11. [SVG NFT Introduction](#svg-nft-introduction)
12. [Encoding the NFT](#encoding-the-nft)
13. [Flipping the Mood](#flipping-the-mood)
14. [SVG NFT Deploy Script](#svg-nft-deploy-script)
15. [SVG NFT Debugging practice](#svg-nft-debugging-practice)
16. [SVG NFT Anvil Demo](#svg-nft-anvil-demo)
17. [Filecoin and Arweave](#filecoin-and-arweave)
18. [EVM Opcodes, Encoding, and Calling](#evm-opcodes-encoding-and-calling)
19. [Verifying Metamask Transactions](#verifying-metamask-transactions)

</details>

<summary> Lesson 12: Defi Stablecoin </summary>

1. [What is defi](#what-is-defi)
2. [Code walkthrough](#code-walkthrough)
3. [Introduction to stablecoins](#introduction-to-stablecoins)
4. [Details for Project](#details-for-project)
5. [Layout of Contract](#layout-of-contract)
6. [Project setup - DSCEngine](#project-setup---dscengine)
7. [Create the deposit collateral function](#create-the-deposit-collateral-function)
8. [Creating the mint function](#creating-the-mint-function)
9. [Creating and retrieving the health factor](#creating-and-retrieving-the-health-factor)
10. [Finishing the mint function](#finishing-the-mint-function)
11. [Creating the deployment script](#creating-the-deployment-script)
12. [Test the DSCEngine smart contract](#test-the-dscengine-smart-contract)
13. [Create the `depostAndMint` function](#create-the-depostandmint-function)
14. [Create the `redeemCollateral` function](#create-the-redeemcollateral-function)
15. [Setup Liquidations](#setup-liquidations)
16. [Refactor Liquidations](#refactor-liquidations)
17. [`DSCEngine` advanced testing](#dscengine-advanced-testing)
18. [Fuzz and Invariant Tests](#fuzz-and-invariant-tests)
19. [Write Fuzz Tests](#write-fuzz-tests)
20. [Setting up Invariant Tests](#setting-up-invariant-tests)
21. [Create the `depositCollateral` handler](#create-the-depositcollateral-handler)
22. [Create the `redeemCollateral` handler](#create-the-redeemcollateral-handler)
23. [Create the `mintDsc` handler](#create-the-mintdsc-handler)
24. [Debugging the fuzz tests handler](#debugging-the-fuzz-tests-handler)
25. [Create the price feed handler](#create-the-price-feed-handler)
26. [Manage your oracles connection](#manage-your-oracles-connection)
27. [Preparing your protocol for an audit](#preparing-your-protocol-for-an-audit)

</details>

<details>

<summary> Lesson 13: Foundry Upgrades </summary>

1. [Upgradable Smart Contracts Overview](#upgradable-smart-contracts-overview)
2. [Using Delegatecall](#using-delegatecall)
3. [Overview of the EIP-1967](#overview-of-the-eip-1967)
4. [Universal Upgradable Smart Contract](#universal-upgradable-smart-contract)
5. [Deploy upgradeable smart contracts](#deploy-upgradeable-smart-contracts)
6. [Upgrade UUPS proxy smart contracts](#upgrade-uups-proxy-smart-contracts)
7. [Testing UUPS proxies](#testing-uups-proxies)
8. [Deploying the stablecoin on the testnet](#deploying-the-stablecoin-on-the-testnet)

</details>

<details>

<summary> Lesson 14: DAOs and Governance </summary>

1. [Introduction to DAOs](#introduction-to-daos)
2. [Project Setup](#project-setup)
3. [Governance Token](#governance-token)
4. [Creating the governor contract](#creating-the-governor-contract)
5. [Testing the governance smart contract](#testing-the-governance-smart-contract)

</details>

<details>

<summary> Lesson 15: Security and Auditing </summary>

1. [Intro](#intro)
2. [What is a smart contract audit](#what-is-a-smart-contract-audit)
3. [Top security tools](#top-security-tools)
4. [Introduction to manual review](#introduction-to-manual-review)
5. [Introduction to Formal Verification](#introduction-to-formal-verification)

</details>

---

### [Lesson 1: Blockchain Basics](https://www.youtube.com/watch?v=umepbfKp5rI&t=834s)
#### What is a blockchain?
- Bitcoin was created by [Satoshi Nakamoto](https://en.wikipedia.org/wiki/Satoshi_Nakamoto) 	
	- One of the first protocols to use blockchain
	 - [Bitcoin Whitepaper](https://bitcoin.org/bitcoin.pdf)outlines how Bitcoin can make peer to peer transactions in a decentralized network
	 - A network powered by cryptography and decentrality allowing people to engage in censorship resistant finance
	 - Some people see Bitcoin as a store of value similar to gold
		 - Is a store of value the same as something used for day to day transactions? If not, then I don't think Bitcoin should be viewed as a "store of value", as that isn't what the whitepaper intended
		- Similar to gold, Bitcoin has the property of scarcity
- Bitcoin lead to the creation of Ethereum: [Ethereum whitepaper](https://ethereum.org/en/whitepaper/)
	- Created by [Vitalik Buterin](https://en.wikipedia.org/wiki/Vitalik_Buterin)
	- Ethereum used the same blockchain infrastructure with the addition of "smart contracts"
	- In 2015 Ethereum was created with the ability to produce decentralized agreements, decentralized organizations, and other ways to interact without centralized mediation
- ["Smart contracts"](https://chain.link/education/smart-contracts) weren't a new idea upon the release of Ethereum
	- In 1994, [Nick Szabo](https://en.wikipedia.org/wiki/Nick_Szabo) originally came up with the idea of a smart contract: "a set of instructions executed in a decentralized way without the need for a centralized or third party intermediary"
	- We can think of smart contracts as we do traditional contracts: a set of instructions between parties
		- Removes centralized forces and counterparty risk
	- Bitcoin technically does have smart contracts, but they are intentionally "turing incomplete"... it lacks the full functionality that would be given be a programming language
- Blockchains are intentionally walled off and they can't interact with or read/listen to data from the real world (the oracle problem)
	- Blockchains are [deterministic systems](https://en.wikipedia.org/wiki/Deterministic_system) and when external data is needed, [oracles](https://betterprogramming.pub/what-is-a-blockchain-oracle-f5ccab8dbd72)are used
		- Oracles are any device that delivers data to decentralized blockchains or runs external computation
		- To maintain decentralization, a single source of data cannot be relied upon
- [Hybrid Smart Contracts](https://chain.link/education-hub/hybrid-smart-contracts) combine onchain decentralized logic with offchain decentralized data
	- Chainlink is a modular, decentralized oracle network that can both bring external data and external computation into smart contracts
- [Blockchain Terminology](https://connect.comptia.org/content/articles/blockchain-terminology)
	- Layer 2 Blockchains try to solve the scaling problem of layer 1 blockchains
	- Layer 1 blockchains can only get so big, layer 2 helps with this scaling issue
		- There are two main types of layer2s: optimistic rollups and zero knowledge rollups
			- Optimistic: optimism, arbitrum
			- Zero knowledge: zksync, polygon zk evm
	- Dapp = Decentralized Application = Decentralized Protocol = Smart contract
		- A decentralized application is usually the combination of many smart contracts
- [Web3](https://en.wikipedia.org/wiki/Web3)is the idea that blockchains and smart contracts are the next iteration of the web
	- Web1: The permissionless open sourced web with static content
	- Web2: The permissioned web, with dynamic content. Companies run your agreements on the servers
	- Web3: The permissionless web, with dynamic content where decentralized censorship resistant networks run your agreement and code. It is generally accompanied by the idea of user owned ecosystems, where the protocols you interact with you also own a portion of, instead of solely being the product.
- Smart contracts create trust minimized agreements
	- Give rise to unbreakable promises
#### The Purpose of Smart Contracts
- [The value of blockchain and smart contract](https://www.youtube.com/watch?v=_JeRq7Gwj5Y&feature=youtu.be)
- The modern world involves a lot of trust... we have to trust that whoever we are doing business with will fulfil their promises/agreement
	- Businesses or entities don't always keep their promises: [McDonalds scandal](https://www.chicagotribune.com/sns-mcdonalds-story.html)
	- 2008 crash and Robinhood not allowing trading of certain stocks are examples of breakdown of trust
	- Even when trying to resolve issues with systems we have in place like court, it can take years to resolve
	- [The Evolution of agreements](https://www.youtube.com/watch?v=ufVyX7JDCgg)
- [What is a smart contract](https://www.youtube.com/watch?v=ZE2HxTmxfrI)
	- A smart contract is an agreement, contract, or set of instructions that is deployed on a decentralized blockchain
		- It cannot be altered (immutable)
		- It automatically executes
		- Everyone can see the terms of the agreement
- [Chainlink and Oracles](https://www.youtube.com/watch?v=tIUHQ7sDoaU)
	- Oracles bring data from off-chain on-chain, and chainlink does this in a decentralized manner
- Smart contract solve some of the earlier trust issues
	- Uniswap is a decentralized exchange that allows trading 
	- Smart contracts can be applied to anything with a trust assumption
	- The idea of smart contracts facilitate moving away from a brand based world to a math based world
#### Other Blockchain Benefits
1. Decentralization
	- There is no centralized intermediary 
	- Many node operators run a blockchain
2. Transparency and Flexibility
	- Everything on-chain can be viewed anyone
	- Blockchain is pseudo-anonymous 
3. Speed and Efficiency
	- Transactions happen "instantly"
	- Fosters an environment of efficiency in how tasks are accomplished
4. Security and Immutability
	- Once a smart contract is deployed it's immutable... the code can't be changed
	- The nodes offer a form of security in that in order to "hack" the blockchain, one would need control of 51% of the nodes
	- All you need for access is your private key... if your computer and data goes down, the information still persists on the blockchain as long as there is one node running
5. Counterparty Risk Removal
	- Removes the centralized intermediary needed for certain interactions
	- Smart contracts define all the details of an agreement, and therefore there is no reliance on  a third party to uphold the agreement
6. Trust Minimized Agreements
	- Doing the right thing is infrastructural
	- There is an added degree of transparency that smart contracts create offering trust in math rather than brands
#### What have Smart Contracts done so far?
- [Defi](https://chain.link/education/defi)
	- Defi stands for decentralized finance
	- Allows us to participate in financial markets without a centralized intermediary 
- [DAOs](https://betterprogramming.pub/what-is-a-dao-what-is-the-architecture-of-a-dao-how-to-build-a-dao-high-level-d096a97162cc)
	- Decentralized Autonomous Organizations are groups that are governed by a set of instructions or smart contracts on-chain
	- The rules are black and white with much easier engagement
	- Facilitates decentralized voting (not 1 vote per person but weighted votes based on ownership)
- [NFTs](https://www.youtube.com/watch?v=9yuHz6g_P50)
	- Non-fungible tokens that can represent physical goods
	- Common use cases today are applied to art
#### Gas 1: Introduction to Gas
- [Gas and Gas Fees](https://ethereum.org/en/developers/docs/gas/)
	- Transaction fee: amount paid to the block producer for processing the transaction
	- Gas price: cost per unit of gas specified for the transaction in Ether and Gwei... the higher the gas price, the higher the chance of getting included in a block
	- Nodes get paid in ether for processing transactions
	- Transaction fee = gas price * gas used
- [Wei, Gwei, and Ether Converter](https://eth-converter.com/)
	- Different types of transactions require different amount of gas units... based on the complexity of the transaction
- [ETH Gas Station](https://ethgasstation.info/)
#### How Do Blockchains Work?
- [What is a hash?](https://techjury.net/blog/what-is-cryptographic-hash/)
	- A hash is a unique fixed length string, meant to identify a piece of data. They are created by placing data into a "hash function"
	- Regarding the data, when working with SHA256, the algorithm can take virtually any length of data to create a hash output
- [Blockchain Demo](https://andersbrownworth.com/blockchain/)
	- Miners have to solve different problems... they are trying to create/verify a hash based on input details such as a block number, nonce, and data
		- They are trying to find a nonce, that satisfies whatever the problem is (start with 4 zeros), that when combined with the block number/data produces the hash solution
		- So effectively, the nonce is the solution to the problem
	- Nodes in Ethereum take turns trying to solve problems in contrast to a competitive proof of work setting
	- The Genesis block is the first block in the blockchain, and a blockchain is a chain of blocks that point to its previous block
	- For a block, the block #, nonce, and data go into the hashing algorithm to create a hash
	- In a Blockchain, the block #, nonce, data, and previous hash go into the algorithm
	- When dealing with something like tokens, transactions are also a part of the hashing process
- [Summary](https://ethereum.org/en/developers/docs/intro-to-ethereum/)
	- Hash: a unique fixed length string to identify a piece of data
	- Hash algorithm: A function that computed data into a unique hash
	- Mining is the process of finding the "solution" to the blockchain "problem"
		- A "problem" could be finding a hash that starts with four zeros
		- Nodes get paid for mining blocks
	- A block in a blockchain is a list of transactions mined together
	- Blockchains are decentralized: have no single point of authority
	- Nonce is "a number used once" to find the solution to the blockchain problem
		- It is also used to define transaction numbers
#### Signing Transactions
- [Public / Private Keys](https://andersbrownworth.com/blockchain/public-private-keys/keys)
	- Private key exists so the user can create signatures
	- Public keys exists for verification
		- Derived by using a digital signature algorithm on a private key. It can be used publicly to verify the origins of a transaction
	- First step in sending a transaction is signing it with private keys
		- Signing a transaction is a one way process. Someone with a private key signs a transaction by their private key being hashed with their transaction data... anyone can then verify this new transaction hash with the corresponding public key
	- Creating a private key usually involves a mnemonic phrase which is hashed with a hashing algorithm
		- Metamask takes a mnemonic phrase and adds a number with it in the hashing algorithm... so when a new account is created, the same mnemonic phrase is used with a different number as an input to the hashing algorithm
			- This means that losing your private keys risks that account while losing the mneomic phrase puts all accounts created at risk
- [Layer 2 and Rollups](https://ethereum.org/en/developers/docs/scaling/layer-2-rollups/)
- [Decentralized Blockchain Oracles](https://blog.chain.link/what-is-the-blockchain-oracle-problem/)
#### Gas II
- [Block Rewards](https://www.investopedia.com/terms/b/block-reward.asp)
- - Ethereum has a base fee: The minimum gas price to send you transaction
	- Part of a transaction fee involves "burning ethereum" which is a way to remove ethereum from circulation
	- Blockchains have limited block space for transactions... the gas price to include transactions in a block changes based of how much demand there is
	- The base fee is algorithmically adjusted to try to get all blocks 50% full
		- If a block is more the 50% full, the base fee goes up
		- If a block is less than 50% full, the base fee goes down
- Advanced Gas
    - [EIP 1559](https://www.youtube.com/watch?v=MGemhK9t44Q)
    - GWEI, WEI, and ETH
        - [ETH Converter](https://eth-converter.com/)
#### Gas II Summary
- [Run Your Own Ethereum Node](https://geth.ethereum.org/docs/getting-started)
- Block confirmations tells us how many blocks have been mined since the transaction in question was added to the block
- Gas price is the cost of one unit of gas
- Gas limit is the max amount of units of gas that a user is willing to pay
- Gas usage is how many units were actually used
- The Base fee is the base network fee per gas
- The max gas price is the max price a user is willing to pay
- Priority is the max gas price + the miner tip
#### High Level Blockchain Fundamentals
- Traditionally running a website or interacting with something that connects to a server involves a "centralized entity"
	- A centralized entity can have multiple servers but ultimately the servers are owned by a single entity
	- Blockchains run on a network of independent nodes
	- Node: a single instance of a decentralized system
- Anyone can join the network
	- This is what makes blockchains decentralized
- Blockchains are resilient
	- The blockchain and the system will persist so long as there is always one node running
- Blockchain nodes keep lists of the transactions that occur
	- This gives blockchains an immutability trait where nothing can be changed or corrupted
	- A blockchain is a decentralized database and Ethereum provides an extra feature of computation
- [Consensus](https://wiki.polkadot.network/docs/learn-consensus)
	- Proof of work and proof of stake are two forms of consensus
	- Consensus is the mechanism used to agree on the state of a blockchain
	- A consensus protocol can be broken down into two pieces
		1. Chain Selection Algorithm
		2. Sybil Resistance Mechanism
			- Sybil resistance is a blockchain's ability to defend against users create a large number of identities to gain a disproportionately advantageous influence over the system
			- Proof of work is a Sybil resistance mechanism because it define a way to figure out the block author... which node did the work to find the mine
	- Proof of Work and Proof of Stake are two types of Sybil resistance mechanisms
		- Proof of work	
- Chain Selection is combined with pow/pos to create consensus
	- Answers the question of "how do we know which blockchain is the real blockchain"
	- Block confirmations are the number of additional blocks that have been added on since the transaction in question
- [Proof of Stake](https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/)
	- Nodes put up collateral as a Sybil resistance mechanism
	- "Miners" are actually validators
	- Nodes are randomly chosen to propose a new block
	- Much less computationally expensive than proof of work
	- It could be less decentralized as there is a staking cost to participate
- [Proof of Work](https://ethereum.org/en/developers/docs/consensus-mechanisms/pow/)
	- A single node has to go through a very computationally expensive process called mining 
	- No matter how many accounts are made, each still have to go through computational expensive activity
	- The block time is how long it takes between blocks being published
	- Nodes are competing for rewards
	- Gas fees are paid by whoever initialized the transaction
- [Nakamoto Consensus](https://blockonomi.com/nakamoto-consensus/)
	- Bitcoin (and when eth was pow) uses Nakamoto Consensus which a combination of proof of work and longest chain rule... whichever chain has the longest chain or the most number of blocks is going to be the chain that is used
- [The merge](https://ethereum.org/en/eth2/)
- Attacks
	- Sybil Attack: a user or users create many accounts to influence a network
	- 51% Attack: Blockchains will agree on the longest chain so long as it aligns with 51% of the network... so having the longest chain along with 51% of the network will force the rest of the network onto this longest chain
- Longest Chain Rule
	- The system is going to corroborate the blockchain which has the most buy in / is the longest
- Layer 1
	- Base layer blockchain implementation
- Layer 2
	- Any application added on top of a layer 1
	- Arbitrum and Optimism are rollups
		- They rollup their transactions into a layer 1
		- Derive security from base layers whereas sidechains derive security from their own protocol
- Summary
	- PoW and PoS are sybil resistance mechanisms
	- The bigger the blockchain, the more secure
	- Consensus is how the blockchain decides what the state chain is
	- Sharding and rollups are scalability solutions
	- Only so many transactions can fit into a block
	- Gas prices are how much it costs to interact with the blockchain

### [Lesson 2: Welcome to Remix](https://www.youtube.com/watch?v=umepbfKp5rI&t=7842s)
#### Introduction
- [Remix](https://remix.ethereum.org/)
	- A popular web based IDE
- [Solidity Documentation](https://docs.soliditylang.org/en/latest/index.html)

#### Setting Up Your First Contract
- Versioning
	- We start out by declaring the version: ``pragma solidity 0.8.4``
	- ``pragma solidity ^0.8.18`` the caret indicates that any compiler version greater than or equal to 0.8.18 can be used
	- we can also indicate a range ``pragma solidity >=0.8.18 < 0.9.0``
- Take notes in your code!
	- with solidity comments can be created with ``//`` or ``/**/``
- [What is a software license](https://snyk.io/learn/what-is-a-software-license/)
- SPDX License
	- Not required, the compiler will still run without it, but recommended
	- ``//SPDX-License-Identifier: MIT;``
- Compiling
	- Transforming our code in to computer code (bytecode)
	- Computer code is very specific instructions for the blockchain to use for our contract
- Contract Declaration
	- The ``contract`` keyword indicates to solidity the name of our contract
	- Similar to a class in JavaScript/Python

#### Basic Solidity: Types
- [Types & Declaring Variables](https://docs.soliditylang.org/en/v0.8.13/)
    - `uint256`, `int256`, `bool`, `string`, `address`, `bytes32`
	    - ``uint`` defaults to ``uint256``
	    - For readability, its better to be explicit and use ``uint256`` over ``uint``
	    - ``int`` can be positive or negative whereas ``uint``, is always positive (unsigned integer)
	    - A ``string`` is text that represents words... it is a bytes object specifically for text... a string can easily be converted to a bytes object
	    - ``bytes32`` and ``bytes`` are actually not the same unlike ``uint`` and ``uint256``
    - [Solidity Types](https://docs.soliditylang.org/en/latest/types.html)
    - [Bits and Bytes](https://www.youtube.com/watch?v=Dnd28lQHquU)
- Default Initializations
	- values are initialized to 0 if no values are given
- Comments
	- with solidity comments can be created with ``//`` or ``/**/``

#### Basic Solidity: Functions
- Functions
	- Function or methods are a sub section of code that when called will execute a very specific small piece of the codebase
	- Identified by the keyword ``function``
- Deploying a Contract
    - Smart Contracts have addresses just like our wallets
    - Deploying a contract uses the exact same process as sending a transaction... the input field is populated with the bytecode of the transaction
    - Deploying a contract is modifying the blockchain, so it requires gas
- Calling a public state-changing Function
- [Visibility](https://docs.soliditylang.org/en/latest/contracts.html#visibility-and-getters)
	- Visibility is defaulted to internal
	- Functions can have one of four visibility specifiers: public, external, internal, private
		- public: visible internally and externally (creates a getter for storage/state variables)
	- Everything on the blockchain is public, so using private isn't a good way to "hide" information
- Gas III | An example
	- Every time the state of the blockchain is updated, it's going to cost gas
- Scope
	- Like other languages, variables are scoped to the block they were created in
	- If a variable is created inside a function, it is only accessible inside that function
- View & Pure Functions
	- A function marked view means we're only going to read state, state cannot be updated
	- Pure functions can't modify or read from state
	- View and pure functions won't cost gas
	- If a gas cost transaction is calling a view or pure function, then there will be a gas cost

#### Basic Solidity: Structs and Arrays
- Structs
	- Allows for the creation of custom data types
```js
struct Person {
	uint256 favoriteNumber;
	string name;
}

Person public rob = Person(17,"Rob");
Person public bor = Person({favoriteNumber:17,name:"Bor"});
```
- Intro to Storage
	- Smart contracts have permanent storage where variables are saved
	- We can also use the memory keyword to utilize non permanent memory
- Arrays
	- ``uint256[]`` the bracket syntax identifies that we have a list of uint256 values
	- an array in Solidity is similar to arrays in other languages
	- arrays are 0 indexed
	- We can combine the idea of structs and arrays and create an array of structs: ``Person[] public listOfPeople;``
- Dynamic & Fixed Sized
	- Arrays can be fixed in size or dynamic
	- Fixed size arrays are declared when created and dynamic sized arrays can go to any size
- `push` array function
	- Arrays come built in with the ``push`` function

#### Basic Solidity: Compiler Errors and Warnings
- Yellow: Warnings are Ok
	- This won't prevent us from compiling our code
- Red: Errors are not Ok
	- Prevent from compiling code

#### Memory, Storage, Calldata
- 6 Places you can store and access data
    - calldata
    - memory
    - storage
    - code
    - logs
    - stack
- calldata, memory, and storage are they only keywords that we actually use
- calldata and memory indicate that data is only going to exist temporarily... the duration of the function call
	- Inside of functions, most variables automatically default to memory variables
	- strings are a special type?? you have to specify memory or call data (has to do with how arrays work in memory)
	- The difference between memory and calldata is that memory can be changed
	- If a calldata variable is passed as an argument, it can't be modified inside the function while memory can be modified
	- storage is for permanent variables that can be modified
- Arrays, structs, and mappings are special types in Solidity and we have to use these keywords when dealing with them
	- Something like uint256 is a primitive type and Solidity knows where to put a primitive
	- A string is an array of bytes, and Solidity needs direction for storage
	- We don't use the storage keyword when declaring function parameters, only memory or calldata

#### Basic Solidity: Mappings
- [Mappings](https://solidity-by-example.org/mapping)
	- A mapping is like a dictionary... a set of keys with each key returning a special set of information
	- ``mapping(string => uint256) public variableName;
	- In a mapping, the default value for all the keys is 0... looking up a key that doesn't exist will return 0

#### Deploying Your First Smart Contract
- A testnet or mainnet
- Connecting Metamask
- [Find a faucet here](https://docs.chain.link/docs/link-token-contracts/#Sepolia)
- See the faucets at the top of this readme!
- Interacting with Deployed Contracts

#### The EVM and Recap
- The EVM
	- When smart contracts are compiled, it gets compiled down to the EVM (Ethereum Virtual Machine)
	- Any blockchain that's EVM compatible should be able to handle Solidity code
	- Ethereum, Polygon, Arbitrum, Optimishm, Zksync
- The first thing to do in a Solidity smart contract is declare the version and above the version the SPDX license identifier
- A contract is similar to a class in other programming languages
- Solidity has many different types such as: string, bytes, uint, boolean
- A struct is a custom type that can be created
- Arrays and mappings handle a list or dictionary of data
- Functions can modify or read from state
- We can specify different data locations in the parameters of functions

### [Lesson 3: Storage Factory](https://www.youtube.com/watch?v=umepbfKp5rI&t=12598s)
#### Introduction
- [Factory Pattern](https://betterprogramming.pub/learn-solidity-the-factory-pattern-75d11c3e7d29)
- We can use a "factory contract" that can deploy other smart contracts

#### Basic Solidity: Importing Contracts into other Contracts
- Composability
	- The ability of smart contracts to seamlessly interact with each other
- [Solidity new keyword](https://docs.soliditylang.org/en/latest/control-structures.html?highlight=new#creating-contracts-via-new)
	- the general structure of a variable is: type visibility name === uint256 public favoriteNumber;
	- we can do the same thing with a contract... just as we invoke a struct's name to create a new struct variable, we can do the same with a contract: ContractName visbility contractName
		- Solidity is case sensitive, so this naming pattern is used often with contracts
	- Then we use the ``new`` keyword to create an instance of a contract
- [Importing Code in solidity](https://solidity-by-example.org/import)
	- One way to link contracts is to have both contracts in one file... however, it is best practice to keep contracts in separate files
	- Instead of having contracts in the same file, we can import: ``import {SimpleStorage} from './SimpleStorage.sol';``
		- Using named imports is best practice

#### Basic Solidity: Interacting with other Contracts
- To interact, you always need: ABI + Address
- [ABI](https://docs.soliditylang.org/en/latest/abi-spec.html?highlight=abi)
	- Application Binary Interface tells our code how it can interact with another contract

#### Basic Solidity: Inheritance and Overrides
- [Inheritance](https://solidity-by-example.org/inheritance)
	- Using the ``is`` keyword, we can have a child contract Inherit from its parent contract
	- ``Contract A is Contract B{}``
- [Override & Virtual Keyword](https://docs.soliditylang.org/en/latest/contracts.html?highlight=override#function-overriding)
	- In order to "override" a function in the child contract, the parent contract needs to designate the function as virtual
	- The ``virtual`` keyword indicates that a function is overridable

#### Summary
- With the ``new`` keyword, we can deploy contracts from other contracts
- Importing contracts into other contracts is the same as copy/pasting the contract
- Named imports are best practice
- We can interact with other contracts as long as we have the address and the abi
	- Using a contract type automatically gives us the address and the abi
- If we want a child contract to inherit the functionality of some other contract, we can import it and use the ``is`` keyword
	- To override a function from the parent contract, the parent contract must use the ``virtual`` keyword while the

### [Lesson 4: Remix Fund Me](https://www.youtube.com/watch?v=umepbfKp5rI&t=14948s)
#### Sending ETH through a function
- How do we send eth?
	- Whenever eth is sent on the blockchain, there is a value field that gets populated
	- The value field is the amount of native blockchain cryptocurrency that gets sent with every transaction
- payable
	- the first thing we need to to do to send cryptocurrency is use the - [payable](https://solidity-by-example.org/payable) keyword
	- like wallets, contracts can hold funds
- Global values
	- we can access the value of a transaction by using a solidity global, msg.value
	- [msg.value & Other global keywords](https://docs.soliditylang.org/en/latest/cheatsheet.html?highlight=cheatsheet#global-variables)
- [require](https://codedamn.com/news/solidity/what-is-require-in-solidity)
	- we can use a require statement to ensure certain conditions are met
	- ``require(msg.value > 1e18);``
	- ``1e18 = 1 ETH = 1000000000000000000 = 1 * 10 ** 18``
	- on the blockchain, value is handled in wei
	- we can use [Ethereum Unit Converter](https://eth-converter.com/) to make easier conversions
	- require can have an option message: ``require(msg.value > 1e18, "didn't send enough eth");``
- [revert](https://medium.com/blockchannel/the-use-of-revert-assert-and-require-in-solidity-and-the-new-revert-opcode-in-the-evm-1a3a7990e06e)
	- A revert undoes any actions that have been done, and sends the remaining gas back
	- A failed transaction still will require some gas
- [Fields in a Transaction](https://ethereum.org/en/developers/docs/transactions/)
	- Nonce: tx count for the account
	- Gas Price: price per unit of gas (in wei)
	- Gas Limit: max gas that this tx can use
	- To: address that the tx is sent to
	- Value: amount of wei to send
	- Data: what to send to the To address
	- v,r,s: components of tx signature
- [More on v,r,s](https://ethereum.stackexchange.com/questions/15766/what-does-v-r-s-in-eth-gettransactionbyhash-mean)

#### Getting real world price data (Chainlink)
- [What is a blockchain oracle?](https://chain.link/education/blockchain-oracles)
	- Blockchains are deterministic systems which means they can't interact with real world data and events
	- Blockchains are deterministic by design so all the nodes can reach consensus
	- Oracles can help get offchain data
	- A blockchain oracle is any device that interacts with the off-chain world to provide external data or computation to smart contracts
- [What is the oracle problem?](https://blog.chain.link/what-is-the-blockchain-oracle-problem/)
	- Smart contracts are unable to connect with external systems or perform external computation
	- Nodes would never be able to reach consesus if variable/random data from api calls were incorporated
	- Centralized oracles are a point of failure
- [Chainlink](https://chain.link/)
	- Chainlink is a decentralized oracle network for bringing data and external computation into our smart contracts
	- A modular decentralized oracle network that can be customized to deliver any data or do any external computation
	- Customizing can be a lot of work, but there are many chainlink features that come out of the box that are ready to be used in smart contracts
- [Chainlink Price Feeds (Data Feeds)](https://docs.chain.link/docs/get-the-latest-price/)
    - A network of chainlink nodes get data from different exchanges and data providers and brings that information through a network of decentralized chainlink nodes
    -  [data.chain.link](https://data.chain.link/)
- [Chainlink VRF](https://docs.chain.link/docs/chainlink-vrf/)
	- Chainlink verifiable randomness function
- [Chainlink Keepers](https://docs.chain.link/docs/chainlink-keepers/introduction/)
	- Chainklink keepers are chainlink nodes that listen for a registration contract for different specified events
- [Chainlink API Calls](https://docs.chain.link/docs/request-and-receive-data/)
- [Importing Tokens into your Metamask](https://consensys.net/blog/metamask/how-to-add-your-custom-tokens-in-metamask/)
- [Request and Receive Chainlink Model](https://docs.chain.link/docs/architecture-request-model/)

#### Interfaces
- There is a concept in solidity known as the interface
	- For reference - [ChainLink Interface's Repo](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol)
	- The interface has functions defined without any logic, allowing it to be easily used for abi??
	- We don't know what the functions do, we just need to know how to interact with the contract
- A common way people interact with other contracts outside of their projects
	- Get the interface of contract using interface keyword
	- The interface compiles and in return we get an ABI
	- wrap an address around interface keyword allowing us to call any function associated with the interface:
	- ``return AggregatorV3Interface(0x694AA1769357215DE4FAC081bf1f309aDC325306).version();``

#### Importing from NPM / GitHub
- Using too many interfaces pasted into our file can look very cluttered
	- Instead, we can use imports:
	- ``import {AggregatorV3Interface} from "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";``
- [Chainlink NPM Package](https://www.npmjs.com/package/@chainlink/contracts)
	- A package manager that keeps different versions of combinations of code
	- Remix automatically downloads this, but for projects with local IDEs, we have to install the package

#### Getting Prices from Chainlink
```js
function getPrice() public view returns(uint256){
	AggregatorV3Interface priceFeed = AggregatorV3Interface(0x694AA1769357215DE4FAC081bf1f309aDC325306);
	(, int256 price,,,) = priceFeed.latestRoundData();
	return uint256(price * 1e10);
}
```

#### More Solidity math
- Multiply before you divide
	- Solidity only works with whole numbers
- [tuple](https://docs.soliditylang.org/en/latest/abi-spec.html?highlight=tuple#handling-tuple-types)
- [Floating Point Numbers in Solidity](https://stackoverflow.com/questions/58277234/does-solidity-supports-floating-point-number)
- [Type Casting](https://ethereum.stackexchange.com/questions/6891/type-casting-in-solidity)
- Gas Estimation Failed
    - Someone should make an article explaining this error
    - It is a boilerplate error for "something went wrong"... it could be a number of issues... but if the require/revert has a message, then the message should show when this pops up

#### msg.sender
- [msg.sender](https://docs.soliditylang.org/en/latest/cheatsheet.html?highlight=msg.sender)
	- a global variable
	- The account that is interacting with the contract (calling a function / sending eth)
- named mappings
	- We can provide names for the key value pair when we create a mapping:
	- ``mapping(address funder => uint256 amountFunded) public addressToAmountFunded;``

#### Library
- [Library](https://docs.soliditylang.org/en/v0.8.14/contracts.html?highlight=library#libraries)
	- Libraries are similar to contracts but you can't declare any state variables and you can't send ether
	- A library is embedded into the contract if all library functions are internal... otherwise the library must be deployed and then linked before the contract is deployed
	- like a contract is created with the ``contract`` keyword, libraries are created with the ``library`` keyword
- The first input variable for a library is going to be type that we use with the library:
	- ``msg.value.getConversionRate();``
	- If thee function had more parameters, then we would just add it to the library function:
	- ``msg.value.getConversionRate(123);``
- [Solidity-by-example Library](https://solidity-by-example.org/library)

#### SafeMath
- [Openzeppelin Safemath](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol)
	- A common library that was used a lot in smart contracts
	- Compiler versions before 0.8.x did no prevent overflow/underflow
	- The safemath library provided overflow/underflow checks
- [unchecked vs. checked](https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic)
	- In newer compilers, we can revert to the unchecked version with the ``unchecked`` keyword
	- A reason the ``unchecked`` keyword might be used is to save gas

#### For Loop
- [For Loop](https://solidity-by-example.org/loop)
	- A for loop is a way to loop through a list, or to do something in a repeated amount of times
	- For loops in Solidity are similar to loops from other languages
- `/* */` is another way to make comments
```js
for (/*starting index, ending index, step amount*/)
```

#### Resetting an array
- We have an existing address array: ``address[] public funders;``
- If we wanted to reset it, inside a function we could do: ``funders = new address[](0);``
	- We use the new keyword to reset the funders array to a blank array of addresses
	- We use 0 to indicate the length

#### Transfer, Send, and Call
- [Transfer, Send, Call](https://solidity-by-example.org/sending-ether/)
	- These are the three different ways we can send ether
	- transfer (2300 gas, throws error)
		- ``payable(msg.sender).transfer(address(this).balance);``
		- transfer automatically reverts
	- send (2300 gas, returns bool)
		- first we have to declare a variable name:
			- ``bool sendSuccess = payable(msg.sender).send(address(this).balance);``
		- then we have to use it in a require statement with an optional message:
			- ``require(sendSuccess,"Didn't work");``
		- send will only revert with the require statement
	- call (forward all gas or set gas, returns bool)
		- call is a lower level function which can be used to call virtually any function in all of ethereum without needing the abi
		- call returns two variables, bool and a bytes object, and we can account for that using parentheses
			- ``(bool success, bytes memory dataReturned) = payable(msg.sender).call{value: address(this).balance}("");``
			- the bool will be true if the function was successfully called... and if we were to have called a function, than the bytes would be the data returned
	- It can be case by case, but as of now, call is the recommended way to send and receive ethereum
- [this keyword](https://ethereum.stackexchange.com/questions/1781/what-is-the-this-keyword-in-solidity)

#### Constructor
- [Constructor](https://solidity-by-example.org/constructor)
	- using the ``constructor`` keyword, we designate a function that is called when we deploy our contract
```js
constructor() {
	owner = msg.sender;
}
```

#### Modifiers
- [Double equals](https://www.geeksforgeeks.org/solidity-operators/)
	- A single `=`  indicates assignment wheras a double `==` is a comparison
- [Modifier](https://solidity-by-example.org/function-modifier)
	- modifiers allow us create keywords that we can use in function declarations
	- the ``_;`` is a placeholder for the logic in the function that the modifier is applied to
```js
modifier onlyOwner() {
	require(msg.sender == owner, "not the owner");
	_;
}
```

#### Testnet Demo
- [Disconnecting Metamask](https://help.1inch.io/en/articles/4666771-metamask-how-to-connect-disconnect-and-switch-accounts-with-metamask-on-1inch-network)

#### Immutable & Constant
- [Immutable](https://solidity-by-example.org/immutable)
	- If we assign a variable once outside of the block that it is declared, we can use the ``immutable`` keyword
	- immutables aren't stored in storage slots but in the bytecode of the contract
	- the naming convention for immutable variables is to prefix them with ``i_``
- [Constant](https://solidity-by-example.org/constants)
	- If we assign a variable once outside of a function and never change it, we can use the ``constant`` keyword
	- like immutable, constant keywords don't take up a storage spot
	- the naming convention with constants is to use all caps with underscores
- [Current ETH Gas Prices](https://etherscan.io/gastracker)
- If we have variables that only get set one time, we can use Solidity tools to make them more gas efficient
- Naming Conventions
    - [Someone make this!](https://github.com/smartcontractkit/full-blockchain-solidity-course-js/issues/13)

#### Custom Errors
- [Custom Errors Introduction](https://blog.soliditylang.org/2021/04/21/custom-errors/)
	- When we use require statements, the messages have to be stored as strings
	- ``0.8.4`` introduced custom errors that are declared at the top outside of the contract
	- instead of using require, we use if statements

#### Receive and Fallback Function
- [Solidity Docs Special Functions](https://docs.soliditylang.org/en/latest/contracts.html?highlight=fallback#special-functions)
- [Receive](https://docs.soliditylang.org/en/latest/contracts.html?highlight=fallback#receive-ether-function)
	- ``receive() external payable {}``
	- A contract can have at most one receive function declared without using the function keyword
	- The function cannot have arguments, cannot return anything, and must have external visibility with payable state mutability
	- As long as there is no data associated with the transaction (no function specified, no calldata), the receive function will get triggered
		- Whenever we call a function, we're populating the calldata of the transaction with data that points to the function
- [Fallback](https://solidity-by-example.org/fallback)
	- Similar to the receive function, but it works even if data is sent with the transaction

### [Lesson 5: AI Prompting and Forums](https://www.youtube.com/watch?v=umepbfKp5rI&t=21600s)
#### 7 Tips for this Course
- [Original Video](https://www.youtube.com/watch?v=IS5dAkFSo_Y)
- Tinker
	- Try to pinpoint you error
- Ask your AI
	- Works best if you have pinpointed your error
	1. Write clear and specific instructions
	2. Give as much context as possible
	3. Use delimiters to clearly indicate distinct parts of the input
	4. Look out for hallucinations
- Read docs
- Web search
- Ask in a forum
	- peeranah.io
	- stack exchange
- Ask on the support forum or github
- Iterate

#### Formatting a question
- [markdown](https://www.markdownguide.org/basic-syntax/)
- It's a good idea to ask your AI buddy to format your questions in markdown

#### SpeedRunEthereum
- A good next step after this course
- [Challenges](https://speedrunethereum.com/)

### [Lesson 6: Foundry Simple Storage](https://www.youtube.com/watch?v=umepbfKp5rI&t=22979s)
#### Introduction
- [Foundry](https://book.getfoundry.sh/)
	- A smart contract development framework
	- Known specifically for its speed, the fastest to work with
	- Foundry is completely solidity based as opposed to hardhat being js based and brownie being python based
#### Installation & Setup
- [Visual Studio Code](https://code.visualstudio.com/)
    - [Crash Course](https://www.youtube.com/watch?v=WPqXP_kLzpo)
- [VSCode Keybindings](https://code.visualstudio.com/docs/getstarted/keybindings)
- [Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)
- [What is a terminal?](https://code.visualstudio.com/docs/editor/integrated-terminal)

##### Windows Setup (WSL)
- Special Guest [Vasiliy](https://twitter.com/cromewar)
- [WSL](https://docs.microsoft.com/en-us/windows/wsl/install)
    - When working in WSL, use Linux commands instead of Windows commands
- [TroubleShooting](https://docs.microsoft.com/en-us/windows/wsl/troubleshooting)
- `curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash`

> ⚠️ Please use Gitpod as an absolute last resort
>
##### Gitpod
- [Gitpod](https://www.gitpod.io/)
    - **If using this, NEVER share a private key with real money on Gitpod**
    - Ideally you figure out the MacOS, Linux, or Windows install though
#### Local Development Introduction
- `CMD + K` or `CTRL + K` clears the terminal
- `code .` to open VSCode in a new VSCode window
#### Foundry Install
- [https://getfoundry.sh](https://getfoundry.sh/)
	- ``curl -L https://foundry.paradigm.xyz | bash``
	- ``source /c/Users/User/.bashrc``
	- ``foundryup``
- Foundry comes with 4 components
	- forge
	- cast
	- anvil
	- chisel
#### VSCode Setup II
- CoPilot
- Copilot labs
- Hardhat Solidity Extension
- VSCodium
	- open source version of VScode
- Create project directory
	- `mkdir foundry-f23`
	- `cd foundry-f23`
	- `mkdir foundry-simple-storage-f23`
#### Foundry Setup
- [Freecodecamp Bash](https://www.freecodecamp.org/news/bash-scripting-tutorial-linux-shell-script-and-command-line-for-beginners/)
- [Foundry Docs Creating a new project](https://book.getfoundry.sh/projects/creating-a-new-project)
	- $ forge init hello_foundry
#### Formatting Solidity in VSCode
- Format your solidity code with in your `settings.json`
```json
"[solidity]": {
	"editor.defaultFormatter": "NomicFoundation.hardhat-solidity"
},
"[javascript]":{
  "editor.defaultFormatter": "esbenp.prettier-vscode"
}
```
#### Compiling in Foundry
- ``forge build`` or ``forge compile``
#### Deploying to a local chain (Anvil or Ganache)
- ``anvil``
	- creates a local blockchain node similar to ``hardhat node``
- [Ganache](https://trufflesuite.com/ganache/)
	- A "on click blockchain" that provides a user interface
#### Adding Another Network on Metamask
- [ETH JSON RPC](https://ethereum.github.io/execution-apis/api-documentation/)
	- Network name: Localhost
	- New RPC URL: http://127.0.0.1/8545
	- ChainID: 31337
#### Deploying to a local chain (Forge Create)
- ``forge --help``
```
Build, test, fuzz, debug and deploy Solidity contracts.

Usage: forge.exe <COMMAND>

Commands:
  bind               Generate Rust bindings for smart contracts
  build              Build the project's smart contracts [aliases: b, compile]
  cache              Manage the Foundry cache
  clean              Remove the build artifacts and cache directories [aliases: cl]
  completions        Generate shell completions script [aliases: com]
  config             Display the current config [aliases: co]
  coverage           Generate coverage reports
  create             Deploy a smart contract [aliases: c]
  debug              Debugs a single smart contract as a script [aliases: d]
  doc                Generate documentation for the project
  flatten            Flatten a source file and all of its imports into one file [aliases: f]
  fmt                Format Solidity source files
  geiger             Detects usage of unsafe cheat codes in a project and its dependencies
  generate           Generate scaffold files
  generate-fig-spec  Generate Fig autocompletion spec [aliases: fig]
  help               Print this message or the help of the given subcommand(s)
  init               Create a new Forge project
  inspect            Get specialized information about a smart contract [aliases: in]
  install            Install one or multiple dependencies [aliases: i]
  remappings         Get the automatically inferred remappings for the project [aliases: re]
  remove             Remove one or multiple dependencies [aliases: rm]
  script             Run a smart contract as a script, building transactions that can be sent onchain
  selectors          Function selector utilities [aliases: se]
  snapshot           Create a snapshot of each test's gas usage [aliases: s]
  test               Run the project's tests [aliases: t]
  tree               Display a tree visualization of the project's dependency graph [aliases: tr]
  update             Update one or multiple dependencies [aliases: u]
  upload-selectors   Uploads abi of given contract to the https://api.openchain.xyz function selector database [aliases: up]
  verify-check       Check verification status on Etherscan [aliases: vc]
  verify-contract    Verify smart contracts on Etherscan [aliases: v]

Options:
  -h, --help     Print help
  -V, --version  Print version
```

- ``forge create ContractName --interactive``
	- deploy a contract and a private key will be requested
- ``forge create ContractName --private-key PRIVATEKEY``
	- deploy a contract with a private key
	- This is not the best option as we never want to have our private key in plain text
	- use ``history -c`` to clear bash history
- ``forge create ContractName --rpc-url URL --private-key PRIVATE KEY``
	- a more explicit way to deploy
#### Deploying to a local chain (Forge Script)
- Foundry allows us to write a script in Solidity in order to deploy
	- Foundry has a lot built in to give Solidity more functionality outside of just smart contracts
- ``ContractName.s.sol``
	- We use the .s convention when naming our deploy contract/script?
- ``import {Script} from "forge-std/Script.sol";``
	- We need to use this import statement and then apply it to our contract
	- ``contract SimpleStorageScript is Script {}``
- [Cheatcodes](https://book.getfoundry.sh/forge/cheatcodes)
	- The vm keyword is a special keyword we can only use in Foundry
	- You can access cheatcodes easily via the `vm` instance
```js
function run() external returns(SimpleStorage) {
	vm.startBroadcast();
	SimpleStorage simpleStorage = new SimpleStorage();
	vm.stopBroadcast();
	return simpleStorage;
}
```
- The code between these two commands is what we actually send and deploy (transactions)
- ``forge script /script/ContractName.s.sol``
	- Deploys the script with the file we created
	- If we don't specify an RPC, it will run the script on a temporary anvil chain
- ``forge script /script/ContractName.s.sol --rpc-url URL``
	- While anvil is running, this command simulates deployment
- ``forge script /script/ContractName.s.sol --rpc-url UR --broadcast --private-key PRIVATE KEY``
	- Deploys to to local node running with anvil
#### What is a transaction?
- transaction data from "./broadcast/ContractName/dry-run/"
```json
 "transaction": {
        "type": "0x02",
        "from": "0x1804c8ab1f12e6bbf3894d4083f33e07309d1f38",
        "gas": "0xb5c8a",
        "value": "0x0",
        "data": "0x6000805460ff1916905560101960025560c0604052600960809081526839b2bb32b73a32b2b760b91b60a05260039061003890826101a9565b50600480546001600160a01b031916733c44cdddb6a900fa2b585dd299e03d12fa4293bc1790556218d85d60ea1b60055560408051808201825260118152815180830190925260038252622937b160e91b60208381019190915281018290528051600b9081559091600c906100ad90826101a9565b505060408051808201825260118152815180830190925260038252622137b960e91b60208381019190915281018290528051600d90815590925090600e906100f590826101a9565b50505034801561010457600080fd5b50610268565b634e487b7160e01b600052604160045260246000fd5b600181811c9082168061013457607f821691505b60208210810361015457634e487b7160e01b600052602260045260246000fd5b50919050565b601f8211156101a457600081815260208120601f850160051c810160208610156101815750805b601f850160051c820191505b818110156101a05782815560010161018d565b5050505b505050565b81516001600160401b038111156101c2576101c261010a565b6101d6816101d08454610120565b8461015a565b602080601f83116001811461020b57600084156101f35750858301515b600019600386901b1c1916600185901b1785556101a0565b600085815260208120601f198616915b8281101561023a5788860151825594840194600190910190840161021b565b50858210156102585787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b6105f6806102776000396000f3fe608060405234801561001057600080fd5b50600436106100885760003560e01c80636f760f411161005b5780636f760f41146100e6578063b11cdb3a146100f9578063c164682714610102578063e853a1c21461012d57600080fd5b806319e96ec61461008d5780632e64cec1146100ac5780632ebce631146100be5780636057361d146100d1575b600080fd5b610095610135565b6040516100a39291906102e3565b60405180910390f35b6001545b6040519081526020016100a3565b6100956100cc36600461031d565b6101cc565b6100e46100df36600461031d565b600155565b005b6100e46100f43660046103d9565b610201565b6100b060025481565b6100b061011036600461041e565b8051602081830181018051600a8252928201919093012091525481565b6100956102ab565b600b8054600c80549192916101499061045b565b80601f01602080910402602001604051908101604052809291908181526020018280546101759061045b565b80156101c25780601f10610197576101008083540402835291602001916101c2565b820191906000526020600020905b8154815290600101906020018083116101a557829003601f168201915b5050505050905082565b600981815481106101dc57600080fd5b600091825260209091206002909102018054600182018054919350906101499061045b565b604080518082019091528181526020810183815260098054600181018255600091909152825160029091027f6e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7af8101918255915190917f6e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7b0019061028390826104e4565b50505080600a8360405161029791906105a4565b908152604051908190036020019020555050565b600d8054600e80549192916101499061045b565b60005b838110156102da5781810151838201526020016102c2565b50506000910152565b82815260406020820152600082518060408401526103088160608501602087016102bf565b601f01601f1916919091016060019392505050565b60006020828403121561032f57600080fd5b5035919050565b634e487b7160e01b600052604160045260246000fd5b600082601f83011261035d57600080fd5b813567ffffffffffffffff8082111561037857610378610336565b604051601f8301601f19908116603f011681019082821181831017156103a0576103a0610336565b816040528381528660208588010111156103b957600080fd5b836020870160208301376000602085830101528094505050505092915050565b600080604083850312156103ec57600080fd5b823567ffffffffffffffff81111561040357600080fd5b61040f8582860161034c565b95602094909401359450505050565b60006020828403121561043057600080fd5b813567ffffffffffffffff81111561044757600080fd5b6104538482850161034c565b949350505050565b600181811c9082168061046f57607f821691505b60208210810361048f57634e487b7160e01b600052602260045260246000fd5b50919050565b601f8211156104df57600081815260208120601f850160051c810160208610156104bc5750805b601f850160051c820191505b818110156104db578281556001016104c8565b5050505b505050565b815167ffffffffffffffff8111156104fe576104fe610336565b6105128161050c845461045b565b84610495565b602080601f831160018114610547576000841561052f5750858301515b600019600386901b1c1916600185901b1785556104db565b600085815260208120601f198616915b8281101561057657888601518255948401946001909101908401610557565b50858210156105945787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b600082516105b68184602087016102bf565b919091019291505056fea2646970667358221220b36d7516bd2e81c318a8ad665aad931e6d330cdd7ca5094e5bb5e0ce93413b4764736f6c63430008150033",
        "nonce": "0x2",
        "accessList": []
      },
```
- Any time state is changed on the blockchain, it does it in a transaction
	- The differentiator is whatever is in the ``data`` field
	- The data field contains the opcodes
- ``cast`` is a built in foundry command
	- ``cast --to-base 0x714c2 dec // 464066``
- ``cast --help``
```
Perform Ethereum RPC calls from the comfort of your command line

Usage: cast.exe <COMMAND>

Commands:
  4byte                  Get the function signatures for the given
                             selector from https://openchain.xyz [aliases:
                             4, 4b]
  4byte-decode           Decode ABI-encoded calldata using
                             https://openchain.xyz [aliases: 4d, 4bd]
  4byte-event            Get the event signature for a given topic 0
                             from https://openchain.xyz [aliases: 4e, 4be]
  abi-decode             Decode ABI-encoded input or output data
                             [aliases: ad, --abi-decode]
  abi-encode             ABI encode the given function argument,
                             excluding the selector [aliases: ae]
  access-list            Create an access list for a transaction
                             [aliases: ac, acl]
  address-zero           Prints the zero address [aliases:
                             --address-zero, az]
  admin                  Fetch the EIP-1967 admin account [aliases:
                             adm]
  age                    Get the timestamp of a block [aliases: a]
  balance                Get the balance of an account in wei [aliases:
                             b]
  base-fee               Get the basefee of a block [aliases: ba, fee,
                             basefee]
  bind                   Generate a rust binding from a given ABI
                             [aliases: bi]
  block                  Get information about a block [aliases: bl]
  block-number           Get the latest block number [aliases: bn]
  call                   Perform a call on an account without
                             publishing a transaction [aliases: c]
  calldata               ABI-encode a function with arguments [aliases:
                             cd]
  calldata-decode        Decode ABI-encoded input data [aliases:
                             --calldata-decode, cdd]
  chain                  Get the symbolic name of the current chain
  chain-id               Get the Ethereum chain ID [aliases: ci, cid]
  client                 Get the current client version [aliases: cl]
  code                   Get the runtime bytecode of a contract
                             [aliases: co]
  codesize               Get the runtime bytecode size of a contract
                             [aliases: cs]
  completions            Generate shell completions script [aliases:
                             com]
  compute-address        Compute the contract address from a given
                             nonce and deployer address [aliases: ca]
  concat-hex             Concatenate hex strings [aliases:
                             --concat-hex, ch]
  create2                Generate a deterministic contract address
                             using CREATE2 [aliases: c2]
  decode-transaction     Decodes a raw signed EIP 2718 typed
                             transaction [aliases: dt]
  disassemble            Disassembles hex encoded bytecode into
                             individual / human readable opcodes [aliases:
                             da]
  estimate               Estimate the gas cost of a transaction
                             [aliases: e]
  etherscan-source       Get the source code of a contract from
                             Etherscan [aliases: et, src]
  find-block             Get the block number closest to the provided
                             timestamp [aliases: f]
  format-bytes32-string  Formats a string into bytes32 encoding
                             [aliases: --format-bytes32-string]
  from-bin               "Convert binary data into hex data." [aliases:
                             --from-bin, from-binx, fb]
  from-fixed-point       Convert a fixed point number into an integer
                             [aliases: --from-fix, ff]
  from-rlp               Decodes RLP encoded data [aliases: --from-rlp]
  from-utf8              Convert UTF8 text to hex [aliases:
                             --from-ascii, --from-utf8, from-ascii, fu, fa]
  from-wei               Convert wei into an ETH amount [aliases:
                             --from-wei, fw]
  gas-price              Get the current gas price [aliases: g]
  generate-fig-spec      Generate Fig autocompletion spec [aliases:
                             fig]
  hash-zero              Prints the zero hash [aliases: --hash-zero,
                             hz]
  help                   Print this message or the help of the given
                             subcommand(s)
  implementation         Fetch the EIP-1967 implementation account
                             [aliases: impl]
  index                  Compute the storage slot for an entry in a
                             mapping [aliases: in]
  interface              Generate a Solidity interface from a given ABI
                             [aliases: i]
  keccak                 Hash arbitrary data using Keccak-256 [aliases:
                             k]
  logs                   Get logs by signature or topic [aliases: l]
  lookup-address         Perform an ENS reverse lookup [aliases: la]
  max-int                Prints the maximum value of the given integer
                             type [aliases: --max-int, maxi]
  max-uint               Prints the maximum value of the given integer
                             type [aliases: --max-uint, maxu]
  min-int                Prints the minimum value of the given integer
                             type [aliases: --min-int, mini]
  namehash               Calculate the ENS namehash of a name [aliases:
                             na, nh]
  nonce                  Get the nonce for an account [aliases: n]
  parse-bytes32-address  Parses a checksummed address from bytes32
                             encoding. [aliases: --parse-bytes32-address]
  parse-bytes32-string   Parses a string from bytes32 encoding
                             [aliases: --parse-bytes32-string]
  pretty-calldata        Pretty print calldata [aliases: pc]
  proof                  Generate a storage proof for a given storage
                             slot [aliases: pr]
  publish                Publish a raw transaction to the network
                             [aliases: p]
  receipt                Get the transaction receipt for a transaction
                             [aliases: re]
  resolve-name           Perform an ENS lookup [aliases: rn]
  rpc                    Perform a raw JSON-RPC request [aliases: rp]
  run                    Runs a published transaction in a local
                             environment and prints the trace [aliases: r]
  send                   Sign and publish a transaction [aliases: s]
  shl                    Perform a left shifting operation
  shr                    Perform a right shifting operation
  sig                    Get the selector for a function [aliases: si]
  sig-event              Generate event signatures from event string
                             [aliases: se]
  storage                Get the raw value of a contract's storage slot
                             [aliases: st]
  to-ascii               Convert hex data to an ASCII string [aliases:
                             --to-ascii, tas, 2as]
  to-base                Converts a number of one base to another
                             [aliases: --to-base, --to-radix, to-radix, tr,
                             2r]
  to-bytes32             Right-pads hex data to 32 bytes [aliases:
                             --to-bytes32, tb, 2b]
  to-check-sum-address   Convert an address to a checksummed format
                             (EIP-55) [aliases: --to-checksum-address,
                             --to-checksum, to-checksum, ta, 2a]
  to-dec                 Converts a number of one base to decimal
                             [aliases: --to-dec, td, 2d]
  to-fixed-point         Convert an integer into a fixed point number
                             [aliases: --to-fix, tf, 2f]
  to-hex                 Converts a number of one base to another
                             [aliases: --to-hex, th, 2h]
  to-hexdata             Normalize the input to lowercase, 0x-prefixed
                             hex [aliases: --to-hexdata, thd, 2hd]
  to-int256              Convert a number to a hex-encoded int256
                             [aliases: --to-int256, ti, 2i]
  to-rlp                 RLP encodes hex data, or an array of hex data
                             [aliases: --to-rlp]
  to-uint256             Convert a number to a hex-encoded uint256
                             [aliases: --to-uint256, tu, 2u]
  to-unit                Convert an ETH amount into another unit
                             (ether, gwei or wei) [aliases: --to-unit, tun,
                             2un]
  to-wei                 Convert an ETH amount to wei [aliases:
                             --to-wei, tw, 2w]
  tx                     Get information about a transaction [aliases:
                             t]
  upload-signature       Upload the given signatures to
                             https://openchain.xyz [aliases: ups]
  wallet                 Wallet management utilities [aliases: w]

Options:
  -h, --help     Print help
  -V, --version  Print version

Find more information in the book:
http://book.getfoundry.sh/reference/cast/cast.html
```
#### Private Keys
- .env
	- This shouldn't be done for production? testing only
	- we can add private key and rpc url in our env file
	- ``source .env`` will add the environment variables into our shell
	- ``echo $VARIABLE_NAME`` will display on the console
- For the moment a `$PRIVATE_KEY` in the `.env` is okay as long as the `.env` isn't exposed
	- For production, use `--interactive`
	- A keystore file with a password is a good option when it becomes available
	- [dapptools - Ethsign](https://github.com/dapphub/dapptools/blob/master/src/ethsign/README.md)
#### ThirdWeb Deploy
- [nodejs install](https://nodejs.org/en/download)
- [npm install](https://nodejs.org/en/download)
- [thirdweb](https://thirdweb.com/)
	- ``npx thirdweb deploy``
	- Uploads contract data to ipfs, and it automatically gets verified
#### Private Key Summary
```
Summary:
When you look to deploy
with real money, you should use either:
1. A password encrypted keystore
2. Something like thirdweb deploy

The idea is you never want to have
your private key or password
ANYWHERE written in plain text
(Aka, you always want it encrypted)
```
#### Cast Send
```
$ cast send --help
Sign and publish a transaction

Usage: cast.exe send [OPTIONS] [TO] [SIG] [ARGS]... [COMMAND]

Commands:
  --create  Use to deploy raw contract bytecode
  help      Print this message or the help of the given subcommand(s)

Arguments:
  [TO]
          The destination of the transaction.

          If not provided, you must use cast send --create.

  [SIG]
          The signature of the function to call

  [ARGS]...
          The arguments of the function to call

Options:
      --async
          Only print the transaction hash and exit immediately

          [env: CAST_ASYNC=]

      --confirmations <CONFIRMATIONS>
          The number of confirmations until the receipt is fetched

          [default: 1]

      --resend
          Reuse the latest nonce for the sender account

      --unlocked
          Send via `eth_sendTransaction using the `--from` argument or
          $ETH_FROM as sender

  -h, --help
          Print help (see a summary with '-h')

Display options:
  -j, --json
          Print the transaction receipt as JSON

Transaction options:
      --gas-limit <GAS_LIMIT>
          Gas limit for the transaction

          [env: ETH_GAS_LIMIT=]

      --gas-price <PRICE>
          Gas price for legacy transactions, or max fee per gas for EIP1559
          transactions

          [env: ETH_GAS_PRICE=]

      --priority-gas-price <PRICE>
          Max priority fee per gas for EIP1559 transactions

          [env: ETH_PRIORITY_GAS_PRICE=]

      --value <VALUE>
          Ether to send in the transaction, either specified in wei, or as
          a string with a unit type.

          Examples: 1ether, 10gwei, 0.01ether

      --nonce <NONCE>
          Nonce for the transaction

      --legacy
          Send a legacy transaction instead of an EIP1559 transaction.

          This is automatically enabled for common networks without
          EIP1559.

Ethereum options:
  -r, --rpc-url <URL>
          The RPC endpoint

          [env: ETH_RPC_URL=]

      --flashbots
          Use the Flashbots RPC URL (https://rpc.flashbots.net)

      --jwt-secret <JWT_SECRET>
          JWT Secret for the RPC endpoint.

          The JWT secret will be used to create a JWT for a RPC. For
          example, the following can be used to simulate a CL
          `engine_forkchoiceUpdated` call:

          cast rpc --jwt-secret <JWT_SECRET> engine_forkchoiceUpdatedV2
          '["0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c
59bc",
          "0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59
bc",
          "0x6bb38c26db65749ab6e472080a3d20a2f35776494e72016d1e339593f21c59
bc"]'

          [env: ETH_RPC_JWT_SECRET=]

  -e, --etherscan-api-key <KEY>
          The Etherscan (or equivalent) API key

          [env: ETHERSCAN_API_KEY=]

  -c, --chain <CHAIN>
          The chain name or EIP-155 chain ID

          [env: CHAIN=]

Wallet options - raw:
  -f, --from <ADDRESS>
          The sender account

          [env: ETH_FROM=]

  -i, --interactive
          Open an interactive prompt to enter your private key

      --private-key <RAW_PRIVATE_KEY>
          Use the provided private key

      --mnemonic <MNEMONIC>
          Use the mnemonic phrase of mnemonic file at the specified path

      --mnemonic-passphrase <PASSPHRASE>
          Use a BIP39 passphrase for the mnemonic

      --mnemonic-derivation-path <PATH>
          The wallet derivation path.

          Works with both --mnemonic-path and hardware wallets.

      --mnemonic-index <INDEX>
          Use the private key from the given mnemonic index.

          Used with --mnemonic-path.

          [default: 0]

Wallet options - keystore:
      --keystore <PATH>
          Use the keystore in the given folder or file

          [env: ETH_KEYSTORE=]

      --account <ACCOUNT_NAME>
          Use a keystore from the default keystores folder
          (~/.foundry/keystores) by its filename

          [env: ETH_KEYSTORE_ACCOUNT=]

      --password <PASSWORD>
          The keystore password.

          Used with --keystore.

      --password-file <PASSWORD_FILE>
          The keystore password file path.

          Used with --keystore.

          [env: ETH_PASSWORD=]

Wallet options - hardware wallet:
  -l, --ledger
          Use a Ledger hardware wallet

  -t, --trezor
          Use a Trezor hardware wallet

Wallet options - AWS KMS:
      --aws
          Use AWS Key Management Service
```

- Sending a tx cast
	- ``$ cast send CONTRACT ADDRESS "fn(type)" arg --rpc-url $RPC_URL --private-key $PRIVATE_KEY``
- Calling with cast
	- ``cast call CONTRACT ADDRESS "fn()"  --rpc- url $RPC_URL --private-key $PRIVATE_KEY``
	- values are returned in hex so we can use ``cast --to-base HEXVALUE dec``

#### Deploying to a testnet or mainnet
- update .env
	- Add actual private key from metamask
	- add rpc url from one of the providers below
- [Alchemy](https://alchemy.com/?a=673c802981)
	- ``$ forge script script/FILENAME.s.sol --rpc-url $SEPOLIA_RPC_URL --private-key $PRIVATE_KEY --broadcast``
- Other node as a service:
    - [Quicknode](https://www.quicknode.com/endpoints)
    - [Infura](https://www.infura.io/)

#### Verifying a contract the manual way
- [Example verified contract](https://sepolia.etherscan.io/address/0xe2e9f468eb7f063aa01670bb4bce4119fb6e4b65#code)
- Etherscan
	- We can manually verify a contract using etherscan
	- We fill in the blanks and paste our code
	- We now have access to read and write functions we can interact with metamask

#### Cleaning up the Project
- `forge fmt`
	- command that automatically formats all our solidity code
- `README.md`
	- Information about your project

#### Alchemy and the mempool
- [Alchemy](https://alchemy.com/?a=673c802981)
	- Whenever we send a transaction to a blockchain, it enters a mempool
	- The mempool is where transactions go before they get sent

#### Summary
- create a new foundry project: ``forge --init``
- forge
	- used for interacting with and compiling contracts
- cast
	- used for interacting with contracts that have already been deployed
- anvil
	- used to deploy a local blockchain
- sending a transaction with metamask is sending an http post request to an rpc url
- we can take an rpc url from somewhere like alchemy and use it in our foundry projects
- we can compile our code in foundry and write a script in solidity to deploy our contracts
- we can use a ``.env`` file, but we may not want to store private keys there
- ``cast call`` to interact with deployed contracts
- ``forge fmt`` to autoformat code
- we can verify contracts manually


### [Lesson 7: Foundry Fund Me](https://www.youtube.com/watch?v=sas02qSFZ74&t=0s)

#### Setup
- ``forge init``
	- Initiates a foundry project
- ``forge init --no-git``
	- I had to use this command, as forge init kept giving me an error

#### Testing Introduction
- ``forge test``
	- If we have test files in the test directory, this will run the tests

#### Setup Continued
- [Chainlink Brownie Contracts Github Repo](https://github.com/smartcontractkit/chainlink-brownie-contracts)
    `` forge install smartcontractkit/chainlink-brownie-contracts@0.6.1 --no-commit``
- [Dependencies](https://book.getfoundry.sh/projects/dependencies)
- [remappings](https://book.getfoundry.sh/reference/forge/forge-remappings)
	- In our ``foundry.toml`` file in the root directory we add:
		- ``remappings = ["@chainlink/contracts/=lib/chainlink-brownie-contracts/contracts/"]``
	- That should allow us to use this import:
		- ``import {AggregatorV3Interface} from "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";``
- [Chainlink Brownie Contracts](https://github.com/smartcontractkit/chainlink-brownie-contracts)

#### Tests
- [foundry tests](https://book.getfoundry.sh/forge/writing-tests)
	- With foundry, we can write tests in Solidity
- ``import {Test} from "forge-std/Test.sol";``
```js
// SPDX-License-Identifier: MIT
pragma solidity >=0.6.2 <0.9.0;

pragma experimental ABIEncoderV2;

// 💬 ABOUT
// Forge Std's default Test.
// 🧩 MODULES
import {console} from "./console.sol";
import {console2} from "./console2.sol";
import {safeconsole} from "./safeconsole.sol";
import {StdAssertions} from "./StdAssertions.sol";
import {StdChains} from "./StdChains.sol";
import {StdCheats} from "./StdCheats.sol";
import {stdError} from "./StdError.sol";
import {StdInvariant} from "./StdInvariant.sol";
import {stdJson} from "./StdJson.sol";
import {stdMath} from "./StdMath.sol";
import {StdStorage, stdStorage} from "./StdStorage.sol";
import {StdStyle} from "./StdStyle.sol";
import {StdUtils} from "./StdUtils.sol";
import {Vm} from "./Vm.sol";

// 📦 BOILERPLATE
import {TestBase} from "./Base.sol";
import {DSTest} from "ds-test/test.sol";

// ⭐️ TEST
abstract contract Test is TestBase, DSTest, StdAssertions, StdChains, StdCheats, StdInvariant, StdUtils {

// Note: IS_TEST() must return true.
// Note: Must have failure system, https://github.com/dapphub/ds-test/blob/cd98eff28324bfac652e63a239a60632a761790b/src/test.sol#L39-L76.
}
```
- ``function setUp() external {}``
	- The ``setUp`` function always runs first
- [console.log](https://book.getfoundry.sh/reference/forge-std/console-log?highlight=con#console-logging)
	- ``import {Test, console} from "forge-std/Test.sol";``
	- ``forge test -vv``, the amount of `v` is for the amount of variables logged??
```js
contract FundMeTest is Test {
    FundMe fundMe;

    function setUp() external {
        fundMe = new FundMe();
    }

    function testMinimumDollarIsFive() public {
        console.log(fundMe.MINIMUM_USD());
        assertEq(fundMe.MINIMUM_USD(), 6e18);
    }
}
```


#### Debugging Tests I
- Use ``console.log`` to debug
```js
function testOwnerIsMsgSender() public {
        console.log(fundMe.i_owner());
        console.log(msg.sender);
        assertEq(fundMe.i_owner(), address(this));
    }
```


#### Advanced Deploy Script I
- Import ``Script`` to deploy
```js
import {Script} from "forge-std/Script.sol";
import {FundMe} from "../src/FundMe.sol";

contract DeployFundMe is Script {
    function run() external {
        vm.startBroadcast();
        new FundMe();
        vm.stopBroadcast();
    }
}
```


#### Forked Tests
- The test option `-m` regex is deprecated. Please use `--match-test` or `--mt` instead.
- ``forge test -m testPriceFeedVersionIsAccurate -vvv`` is depreciated. Please use
- ``forge test --match-test testPriceFeedVersionIsAccurate -vvv``
- 4 types of testing:
	1. Unit:
		- Testing a specific part of our code
		- Testing a single function
	2. Integration:
		- Testing multiple functions
		- Testing how our code works with other parts of our code
	3. Forked:
		- Testing on a forked network
		- Testing our code on a simulated real enviornment
	1. Staging:
		- Testing on a live network (testnet or mainnet)
		- Testing our code in a real environment that isn't production

- [forking in foundry](https://book.getfoundry.sh/forge/fork-testing?highlight=fork#forking-cheatcodes)
	- after adding rpc url to ``.env``, run ``source env``
	- ``forge test --match-test testPriceFeedIsAccurate -vvv --fork-url $SEPOLIA_RPC_URL``
- [forge coverage](https://book.getfoundry.sh/reference/forge/forge-coverage?highlight=cover#description)
	- ``forge coverage --fork-url $SEPOLIA_RPC_URL``
	- shows how much of our code is actually tested

#### Refactoring I: Testing Deploy Scripts
- Refactoring
	- Refactoring is when we change the architecture of our code without changing the functionality
- Instead of having to refactor each file, look for ways to share logic
```js
import {FundMe} from "../src/FundMe.sol";
import {DeployFundMe} from "../script/DeployFundMe.s.sol";

function setUp() external {
	// fundMe = new FundMe(0x694AA1769357215DE4FAC081bf1f309aDC325306);
	DeployFundMe deployFundMe = new DeployFundMe();
	fundMe = deployFundMe.run();
}
```

#### Refactoring II: Helper Config
- RPC URL
	- Ideally, we don't want to make too many calls to our RPC URL... we want to test locally for as long as possible
- Mock contract
	- On our local anvil, we can deploy a "fake"/mock contract and interact with that for our tests
- [block.chainid](https://docs.soliditylang.org/en/v0.8.19/units-and-global-variables.html)
	- A solidity global variable
	- refers to the chain's current id
- [Chain ID List](https://chainlist.org/)
    - 11155111 is ETH Sepolia
    - 1 is ETH Mainnet
- Anything before ``vm.StartBroadcast()`` is not sent as a real transaction

#### Refactoring III: Mocks
- [Mocking](https://stackoverflow.com/questions/2665812/what-is-mocking)
	- We have to deploy mock contracts ourselves on anvil
	- A mock contract is a dummy contract
- [Chainlink Github](https://github.com/smartcontractkit/chainlink)
- Multiple Versions of Solidity

#### Magic Numbers
- [Style Guide](https://docs.soliditylang.org/en/v0.8.17/style-guide.html)
- [Magic Numbers](https://codeburst.io/software-anti-patterns-magic-numbers-7bc484f40544)
	- A _magic number_ is a number in the code that seems arbitrary and has no context or meaning. This is considered an anti-pattern because it makes code difficult to understand and maintain.
	- A solution is to turn these "magic numbers" into constant variables

#### Refactoring III: Mocking
```js
if(activeNetworkConfig.priceFeed != address(0)) {
	return activeNetworkConfig;
}
```
- If we've already deployed a price feed, this check will prevent us from deploying a new one
	- ``address(0)`` is the "zero address" which is what the value would be if we haven't deployed the price feed contract
- ``getOrCreateAnvilEthConfig()``
	- Try to be verbose when naming to make code more readable

#### More Cheatcodes
- [foundry cheatcodes](https://book.getfoundry.sh/forge/cheatcodes)
- [forge std cheats](https://book.getfoundry.sh/reference/forge-std/)
    - [vm.expectRevert](https://book.getfoundry.sh/cheatcodes/expect-revert?highlight=expectRevert#expectrevert)
	    - for tests, this indicates that the next line should revert
    - [vm.prank](https://book.getfoundry.sh/cheatcodes/prank?highlight=prank#prank)
	    - Sometimes it can be difficult to know who is sending transactions in a test environment
	    - sets the msg.sender for the specified address for the next call
    - [makeAddr](https://book.getfoundry.sh/reference/forge-std/make-addr?highlight=makeAddr#makeaddr)
	    - Creates an address derived from the provided `name`.
	    - comes from forge/std as opposed to the vm
	    - ``address USER = makeAddr("user");``
    - [deal](https://book.getfoundry.sh/cheatcodes/deal?highlight=deal#deal)
	    - allows us to set the balance of a new address
- Storage variables
	- a naming convention for storage variables is ``s_`` prefix
- Private variables
	- It's best practice to use private variables because they're more gas efficient
	- Use external view functions to get the values of the private variables

#### More Coverage
- modifier
	- allows use to fund an account with a modifier rather than using the code in the function every time
```js
modifier funded() {
   vm.prank(USER);
   fundMe.fund{value: SEND_VALUE}();
   _;
}
```
- [State tree testing](https://twitter.com/PaulRBerg/status/1624763320539525121?s=20)
- Arrange, Act, Assert
	- A pattern to have in mind when working with tests
	- First we arrange the test
	- Then we perform the action associated with the test
	- Finally, we assert the test
- [hoax](https://book.getfoundry.sh/reference/forge-std/hoax?highlight=hoax#hoax)
	- Sets up an address with some ether
- uint160 -> address
	- As of solidity 0.8, you can no longer cast explicitly from ``address`` to uint256
	- We can use uint160, because it has the same amount of bytes as an address??
- [vm.startPrank](https://book.getfoundry.sh/cheatcodes/start-prank?highlight=startPrank#startprank)
	- Similar to start/stop broadcast, anything in between is going to be sent with the address used for startPrank

#### Chisel
- [Chisel](https://book.getfoundry.sh/reference/chisel/?highlight=chisel#chisel)
	- Chisel is a Solidity REPL (short for "read-eval-print loop") that allows developers to write and test Solidity code snippets. It provides an interactive environment for writing and executing Solidity code, as well as a set of built-in commands for working with and debugging your code. This makes it a useful tool for quickly testing and experimenting with Solidity code without having to spin up a sandbox foundry test suite.
- ``chisel``... ``!help``
```
General
        !help | !h - Display all commands
        !quit | !q - Quit Chisel
        !exec <command> [args] | !e <command> [args] - Execute a shell command and print the output

Session
        !clear | !c - Clear current session source
        !source | !so - Display the source code of the current session
        !save [id] | !s [id] - Save the current session to cache
        !load <id> | !l <id> - Load a previous session ID from cache
        !list | !ls - List all cached sessions
        !clearcache | !cc - Clear the chisel cache of all stored sessions
        !export | !ex - Export the current session source to a script file
        !fetch <addr> <name> | !fe <addr> <name> - Fetch the interface of a verified contract on Etherscan
        !edit - Open the current session in an editor

Environment
        !fork <url> | !f <url> - Fork an RPC for the current session. Supply 0 arguments to return to a local network
        !traces | !t - Enable / disable traces for the current session
        !calldata [data] | !cd [data] - Set calldata (`msg.data`) for the current session (appended after function selector). Clears it if no argument provided.

Debug
        !memdump | !md - Dump the raw memory of the current state
        !stackdump | !sd - Dump the raw stack of the current state
        !rawstack <var> | !rs <var> - Display the raw value of a variable's stack allocation. For variables that are > 32 bytes in length, this will display their
 memory pointer.
 ```
#### Cheaper WIthdraw
- Every transaction in chain requires gas
	- The more computationally expensive a transaction, the more gas we have to spend
- [Gas Reporter](https://book.getfoundry.sh/forge/gas-reports)
- `forge snapshot`
	- creates a gas snapshot file
	- tells us how much a test we run will cost in gas
	- ``FundMeTest:testWithdrawFromMultipleFunders() (gas: 516683)``
- `vm.txGasPrice`
- `gasLeft()`
	- A built in function from Solidity
	- Tells us how much gas is left in our transaction call
- `tx.getprice`
	- When working with anvil, gas price defaults to 0
	- We have to tell our test to pretend to use a real gas price
	- ``tx.gasprice`` sets the gas price for the rest of the transaction
- checking gas with foundry
```js
uint256 gasStart = gasleft();
vm.txGasPrice(GAS_PRICE);
uint256 gasEnd = gasleft();

uint256 gasUsed = (gasStart - gasEnd) * tx.gasprice;
console.log(gasUsed);
```

#### Storage
- [Storage Layout](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html)
	- Variables persist because they get saved to storage
	- Each storage slot is 32 bytes long, and represents the bytes version of an object
		- For example the uint256 25 is 0x000...0019 since that's the hex representation
		- For a "true" boolean, it would be 0x000... 001
	- For dynamic values like mappings and dynamic arrays, the elements are stored using a hashing function
		- For arrays, a sequential storage spots is taken up for the length of the array
		- For mappings, a sequential storage spots is taken up but left blank
	- Constant variables and immutable variables do not take up spots in storage
		- They are considered part of the core of the bytecode
	- Variables inside functions only exist for the duration of the function
- ``forge inspect``
	- We can run ``forge inspect ContractName storageLayout`` to see the storage layout of the contract
- ``cast storage``
	- Another command to check storage
	- ``cast storage <CONTRACT ADDRESS> <storage slot>`` to check a specific storage slot
- [Purpose of the memory keyword](https://stackoverflow.com/questions/33839154/in-ethereum-solidity-what-is-the-purpose-of-the-memory-keyword)
- [Opcodes](https://ethereum.org/en/developers/docs/evm/opcodes/)
	- Bytecode is converted to opcodes
	- Low level computer assembly instructions that are actually executing
- [Opcodes by Gas](https://github.com/crytic/evm-opcodes)
	- reading and saving to storage ``SSLOAD`` and ``SSTORE`` cost 100 gas
	- loading and storing from memory ``MLOAD`` and ``MSTORE`` costs 3 gas
- [Opcodes by Gas](https://evm.codes/)
- Append `s_` to storage variables
- Append `i_` to immutable variables
- Caps lock and underscore constant variables
- [Chainlink Solidity Style Guide](https://github.com/smartcontractkit/full-blockchain-solidity-course-js/issues/13)
- private variables
	- They are not hidden. The blockchain is public and private variables can be accessed from storage slots

#### Cheaper Withdraw II
- Reading and writing from storage is an expensive operation
- [evm.codes](https://www.evm.codes/)
- [Style Guide](https://docs.soliditylang.org/en/latest/style-guide.html)
    - [Chainlink Style Guide](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/STYLE.md)
- [NatSpec](https://docs.soliditylang.org/en/latest/natspec-format.html)

#### Interactions.s.sol
- [foundry devops](https://github.com/Cyfrin/foundry-devops)
	- ``forge install Cyfrin/foundry-devops --no-git``
- [Best README Template](https://github.com/othneildrew/Best-README-Template)
- [ffi](https://book.getfoundry.sh/cheatcodes/ffi?highlight=ffi#ffi)
	- in ``foundry.toml`` set ``ffi = true``
	- allows us to run bash scripts from foundry
	- more often than not, this should be off
- ``get_most_recent_deployment``
	- get the most recently deployed version of a contract
	- ``DevOpsTools.get_most_recent_deployment(contractName, chainId);``
- Integration tests
	- Test interactions and combinations of systems

#### Makefile
- Makefiles allow us to create shortcuts for commands we use often
	- ``-include .env``
	- ``build:; forge build``
		- The semicolon allows us to write the prompt on the same line
	- run the commands with make: ``make build``

```
deploy-sepolia:
    forge script script/DeployFundMe.s.sol:DeployFundMe --rpc-url $(SEPOLIA_RPC_URL) --private-key $(PRIVATE_KEY) --broadcast --verify --etherscan-api-key $(ETHERSCAN_API_KEY) -vvvv
```

- [Install make](https://stackoverflow.com/questions/39892692/how-to-implement-make-install-in-a-makefile)
- [Install make Ubuntu](https://linuxhint.com/install-use-make-ubuntu/).
- [Etherscan API Key](https://docs.etherscan.io/getting-started/viewing-api-usage-statistics)

```
-include .env

.PHONY: all test clean deploy fund help install snapshot format anvil

DEFAULT_ANVIL_KEY := 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80

help:
	@echo "Usage:"
	@echo "  make deploy [ARGS=...]\n    example: make deploy ARGS=\"--network sepolia\""
	@echo ""
	@echo "  make fund [ARGS=...]\n    example: make deploy ARGS=\"--network sepolia\""

all: clean remove install update build

# Clean the repo
clean  :; forge clean

# Remove modules
remove :; rm -rf .gitmodules && rm -rf .git/modules/* && rm -rf lib && touch .gitmodules && git add . && git commit -m "modules"

install :; forge install cyfrin/foundry-devops@0.0.11 --no-commit && forge install smartcontractkit/chainlink-brownie-contracts@0.6.1 --no-commit && forge install foundry-rs/forge-std@v1.5.3 --no-commit

# Update Dependencies
update:; forge update

build:; forge build

test :; forge test

snapshot :; forge snapshot

format :; forge fmt

anvil :; anvil -m 'test test test test test test test test test test test junk' --steps-tracing --block-time 1

NETWORK_ARGS := --rpc-url http://localhost:8545 --private-key $(DEFAULT_ANVIL_KEY) --broadcast

ifeq ($(findstring --network sepolia,$(ARGS)),--network sepolia)
	NETWORK_ARGS := --rpc-url $(SEPOLIA_RPC_URL) --private-key $(PRIVATE_KEY) --broadcast --verify --etherscan-api-key $(ETHERSCAN_API_KEY) -vvvv
endif

deploy:
	@forge script script/DeployFundMe.s.sol:DeployFundMe $(NETWORK_ARGS)

fund:
	@forge script script/Interactions.s.sol:FundFundMe $(NETWORK_ARGS)

withdraw:
	@forge script script/Interactions.s.sol:WithdrawFundMe $(NETWORK_ARGS)
```
- ``cast send``
	- Instead of using scripts, we can also use ``cast send``

#### Push to GitHub
- Add these to your `.gitignore`
    - `.env`
    - `lib/`
    - `broadcast/`
- [Git Docs](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)
- [GitHub docs](https://docs.github.com/en)
- [Github Quickstart](https://docs.github.com/en/get-started/quickstart)
- [What is Git?](https://www.git-scm.com/book/en/v2/Getting-Started-What-is-Git%3F)
- [The quickstart that we follow in the video](https://docs.github.com/en/get-started/importing-your-projects-to-github/importing-source-code-to-github/adding-locally-hosted-code-to-github#adding-a-local-repository-to-github-using-git)
- [Learn about git and GitHub](https://www.youtube.com/watch?v=RGOj5yH7evk)


### [Lesson 8 HTML Fund Me](https://www.youtube.com/watch?v=sas02qSFZ74&t=9422s)
#### How Metamask works with your browser
- [Metamask Docs](https://docs.metamask.io/)
	- Metamask injects "ethereum" into the browser
	- Metamask has an rpc-url that makes api calls
- [Ethers Docs](https://docs.ethers.org/v5/)
	- Metamask uses ethers

#### Introduction to Function Selectors

- [Function selector](https://ethereum.stackexchange.com/questions/49996/what-is-the-function-selector-of-the-fallback-function?rq=1)
	- All the functions in a smart contract get transformed into function selectors
- [cast sig](https://book.getfoundry.sh/reference/cast/cast-sig?highlight=sig#cast-sig)


### [Lesson 9 Foundry Smart Contract Lottery](https://www.youtube.com/watch?v=sas02qSFZ74&t=11049s)
#### Raffle.sol Setup
- Natspec
```
/**
 * @title A sample raffle contract
 * @author Robin Punnose
 * @notice this contract is made for creating a sample raffle
 * @dev Implements Chainlink VRFv2
*/
```

#### Solidity Contract Layout
- [Layout](https://docs.soliditylang.org/en/latest/layout-of-source-files.html)
```
// Layout of Contract:
// version
// imports
// errors
// interfaces, libraries, contracts
// Type declarations
// State variables
// Events
// Modifiers
// Functions

// Layout of Functions:
// constructor
// receive function (if exists)
// fallback function (if exists)
// external
// public
// internal
// private
// internal & private view & pure functions
// external & public view & pure functions
```


#### Custom Errors
- Custom errors
	- solidity v0.8.4 added custom errors
	- Instead of using require, we use an if statement with a revert
	- custom errors are more gas efficient
	- ``require`` is important to know because it's used a lot, but we should always use if with revert for gas efficiency
- Naming
	- Best practice to use the name of the contract followed by two underscores
	- ``error Raffle___NotEnoughEthSent();``

#### Events
- As a rule of thumb whenever we make a storage update/ change state, we should emit an event
- The EVM can emit logs
	- When things happen on a blockchain, the EVM writes these things to a specific data structure called its log
	- Logs and events are often used synonymously
- Events allow us to "print" to the log structure
	- This is more gas efficient than storing to a variable
- Logs aren't accessible to smart contracts
- Events are tied to the smart contract that emitted the event
- [Graph](https://thegraph.com/) listens to and stores event data
```js
event StoredNumer(
	uint256 indexed oldNumber,
	uint256 indexed newNumber,
	uint256 addedNumber,
	address sender
)
```
- An event can have up to three ``indexed`` parameters (known as topics)
	- Indexed parameters are much easier to search for
- Events need to be emitted
```js
emit StoredNumber(
	favoriteNumber,
	_favoriteNumber,
	_favoriteNumber + favoriteNumber,
	msg.sender
)
```
- A an event found in the logs will have the following information:
	- The address the event is emitted from
	- The topics (indexed parameters) of the event
	- Data includes the abi encoded non indexed parameters of the event
		- The non indexed parameters are grouped together and placed in an encoding algorithm
- Non indexed parameters cost less gas but they are harder to query

#### block.timestamp
- a global variable
	- Each block contains a unix timestamp
- [manipulation](https://solidity-by-example.org/hacks/block-timestamp-manipulation/)

#### Chainlink VRF
- Using VRF is funding a subscription
	- An account that allows use to fund and maintain a balance for multiple contracts
	- A bucket that all our contracts can pull from
- [docs](https://docs.chain.link/)
	- [random number](https://docs.chain.link/vrf/v2/subscription/examples/get-a-random-number)
	- We create a subscription and we have to let our contract and subscription know about each other
	- [VRFv2Consumer.sol](https://remix.ethereum.org/#url=https://docs.chain.link/samples/VRF/VRFv2Consumer.sol&lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.18+commit.87f61d96.js)
- Gas Lanes
	- The gas lane to use, which specifies the maximum gas price to bump to.
	- For a list of available gas lanes on each network, see https://docs.chain.link/docs/vrf/v2/subscription/supported-networks/#configurations
	- ``bytes32 keyHash = 0x474e34a077df58807dbe9c96d3c009b23b3c6d0cce433e59bbf5b34f823bc56c;``
- How it works
	- The VRF makes a request to the oracle network
	- The oracle network generates the random numbers
	- If we don't do something with the random numbers right away, they are stored and the information becomes public
	- ``callbackGasLimit`` is the maximum amount of gas that's available to be used in the callback function
	- we can set the amount of block confirmation, the lower the number the faster, but less secure
#### Implementing Chainlink VRG
- [Get Sepolia Testnet LINK tokens](https://faucets.chain.link/)
- [Chainlink docs - create a random number](https://docs.chain.link/vrf/v2/subscription/examples/get-a-random-number#create-and-fund-a-subscription)
- [Chainlink Brownie Contracts](https://github.com/smartcontractkit/chainlink-brownie-contracts
- ``forge install smartcontractkit/chainlink-brownie-contracts@0.6.1 --no-git``
- ``foundry.toml``
	- ``remappings = ["@chainlink/contracts=/lib/chainlink-brownie-contracts/contracts"]``
- Inheritance
	- If we inherit from a contract that has a constructor, we need to pass any necessary arguments from the inherited contract to our contract
```js
constructor(
	uint256 _entranceFee,
	uint256 _interval,
	address _vrfCoordinator,
	bytes32 _gasLane,
	uint64 _subscriptionId,
	uint32 _callbackGasLimit
) VRFConsumerBaseV2(_vrfCoordinator) {
	i_entranceFee = _entranceFee;
	i_interval = _interval;
	i_vrfCoordinator = VRFCoordinatorV2Interface(_vrfCoordinator);
	i_gasLane = _gasLane;
	i_subscriptionId = _subscriptionId;
	i_callbackGasLimit = _callbackGasLimit;
	s_lastTimestamp = block.timestamp;
}
```

#### Chainlink Summary
- We are making a request to the chainlink node to give us a random number
- Chainlink will generate the random number and call the ``VRFCoordinator`` contract where only the Chainlink node can respond to it
- That contract will call the ``rawFulfillRandomWords`` function

#### Modulo
- The modulo function performs the divide operation and returns the remainder

#### Enum
- We want to create a state where if we're in the middle of a raffle, we don't want a new raffle to occur
- [Enum](https://solidity-by-example.org/enum/)
	- We can use the enum type to keep track of state
	- The enum types are converted to integers by solidity, so below ``OPEN`` would be 0 and ``CALCULATING`` would be 1
```js
enum RaffleState {
	OPEN,
	CALCULATING
}
```
- We can create a variable based on the enum
	- ``RaffleState private s_raffleState;``
- We can adjust the state as we need
	- ``s_raffleState = RaffleState.OPEN;``
	- ``s_raffleState = RaffleState.CLOSED;``

#### Resetting an Array
- ``s_players = new address payable[](0);``

#### CEI (Checks, Effects, Interactions)
- A design pattern meant to help us stay secure and safe
- Checks
	- Things like require statements and errors
	- This is generally how we want to start because it's more gas efficient
- Effects
	- Where we effect our own contract
- Interactions
	- Our interactions with other contracts
	- We want to interact with other contracts last as a means to mitigate reentrancy
- Some people emit events after interactions but it makes sense to emit events in the effects portion of our code

#### Chainlink Automation
- [Chainlink Automation](https://dev.chain.link/products/automation)
	- Chainlink Automation was previously known as Chainlink Keepers
- [crontab](https://crontab.guru/)
- ``function checkUpkeep(bytes memory /*checkData*/) public {}``
	- If a function requires an input parameter, but it's not going to be used, we can comment it out
- Custom error arguments
	- We can give our custom errors arguments ``error Raffle__UpkeepNotNeeded(uint256 currentBalance, uint256 numPlayers, uint256 raffleState);``

#### Test and Deploy Script Setup
```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import {Script} from "forge-std/Script.sol";

contract HelperConfig is Script {
    struct NetworkConfig {
        uint256 entranceFee;
        uint256 interval;
        address vrfCoordinator;
        bytes32 gasLane;
        uint64 subscriptionId;
        uint32 callbackGasLimit;
    }

    NetworkConfig public activeNetworkConfig;

    constructor() {
        if (block.chainid == 11155111) {
            activeNetworkConfig = getSepoliaEthConfig();
        } else {
            activeNetworkConfig = getOrCreateAnvilEthConfig();
        }
    }

    function getSepoliaEthConfig() public view returns(NetworkConfig memory) {
        return NetworkConfig({
            entranceFee: 0.01 ether,
            interval: 30,
            vrfCoordinator: 0x8103B0A8A00be2DDC778e6e7eaa21791Cd364625,
            gasLane: 0x474e34a077df58807dbe9c96d3c009b23b3c6d0cce433e59bbf5b34f823bc56c,
            subscriptionId: 0, // update this with our subId
            callbackGasLimit: 500000 // 500,000 gas
        });
    }

    function getOrCreateAnvilEthConfig() public returns(NetworkConfig memory){
        if (activeNetworkConfig.vrfCoordinator != address(0)) {
            return activeNetworkConfig;
        }
    }
}
```

#### VRF Mocks
- ``/chainlink-brownie-contracts/contracts/src/v0.8/mocks/VRFCoordinatorV2Mock.sol``
	- Rather than writing our own mock, we can use the one provided
```solidity
 function getOrCreateAnvilEthConfig() public returns(NetworkConfig memory){
        if (activeNetworkConfig.vrfCoordinator != address(0)) {
            return activeNetworkConfig;
        }

        uint96 baseFee = 0.25 ether; // 0.25 Link
        uint96 gasPriceLink = 1e9; // 1 gwei Link

        vm.startBroadcast();
        VRFCoordinatorV2Mock vrfCoordinatorMock = new VRFCoordinatorV2Mock(baseFee, gasPriceLink);
        vm.startBroadcast();

        return NetworkConfig({
            entranceFee: 0.01 ether,
            interval: 30,
            vrfCoordinator: address(vrfCoordinatorMock),
            gasLane: 0x474e34a077df58807dbe9c96d3c009b23b3c6d0cce433e59bbf5b34f823bc56c,
            subscriptionId: 0, // our script will add this
            callbackGasLimit: 500000 // 500,000 gas
        });
```
- I was running into an error because of the code I have above.
	- The code above is using ``vm.startBroadcast();`` twice
	- ``[FAIL. Reason: Setup failed: You have an active broadcast already.]``
	- the second ``startBroadcast`` should be ``vm.stopBroadcase();``
#### Tests and Deploy Scripts Continued
- forge coverage: check your files to see how much of it is being tested
- ``forge test --mt <testname>``
```solidity
// DeployRaffle.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import {Script} from "forge-std/Script.sol";
import {Raffle} from "../src/Raffle.sol";
import {HelperConfig} from "./HelperConfig.s.sol";

contract DeployRaffle is Script {
    function run() external returns (Raffle) {
        HelperConfig helperConfig = new HelperConfig();
        (
            uint256 entranceFee,
            uint256 interval,
            address vrfCoordinator,
            bytes32 gasLane,
            uint64 subscriptionId,
            uint32 callbackGasLimit
        ) = helperConfig.activeNetworkConfig();

        vm.startBroadcast();
        Raffle raffle = new Raffle(
            entranceFee,
            interval,
            vrfCoordinator,
            gasLane,
            subscriptionId,
            callbackGasLimit
        );
        vm.stopBroadcast();
        return raffle;
    }
}
```

```solidity
// RaffleTest.t.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import {DeployRaffle} from "../../script/DeployRaffle.s.sol";
import {Raffle} from "../../src/Raffle.sol";
import {Test, console} from "forge-std/Test.sol";
import {HelperConfig} from "../../script/HelperConfig.s.sol";

contract RaffleTest is Test {
    Raffle raffle;
    HelperConfig helperConfig;
    uint256 entranceFee;
    uint256 interval;
    address vrfCoordinator;
    bytes32 gasLane;
    uint64 subscriptionId;
    uint32 callbackGasLimit;

    address public PLAYER = makeAddr("player");
    uint256 public constant STARTING_USER_BALANCE = 10 ether;

    function setUp() external {
        DeployRaffle deployer = new DeployRaffle();
        (raffle, helperConfig) = deployer.run();
         (
            entranceFee,
            interval,
            vrfCoordinator,
            gasLane,
            subscriptionId,
            callbackGasLimit
        ) = helperConfig.activeNetworkConfig();
    }

    function testRaffleInitializesInOpenState() public view{
        assert(raffle.getRaffleState() == Raffle.RaffleState.OPEN);
    }

}
```

#### Lots of Tests
- Name tests with "test"
	- I was having issues getting a test to run... the test was "running" but it didn't pass or fail
	- I has named the test ``raffleRecordsPlayerWhenTheyEnter()`` which is why it wasn't working
	- It should have been ``testRaffleRecordsPlayerWhenTheyEnter()``
```solidity
function testRaffleRevertsWhenYouDontPayEnough() public {
        // Arrange
        vm.prank(PLAYER);
        // Act / Assert
        vm.expectRevert(Raffle.Raffle__NotEnoughEthSent.selector);
        raffle.enterRaffle();
    }
```

```solidity
    function testRaffleRecordsPlayerWhenTheyEnter() public {
        vm.prank(PLAYER);
        raffle.enterRaffle{value:entranceFee}();
        address playerRecorded = raffle.getPlayer(0);
        assert(playerRecorded == PLAYER);
    }
```

#### Testing Events in Foundry
- [expectEmit](https://book.getfoundry.sh/cheatcodes/expect-emit?highlight=expectEmit#expectemit)
```solidity
function expectEmit(
    bool checkTopic1,
    bool checkTopic2,
    bool checkTopic3,
    bool checkData,
    address emitter
) external;
```

```solidity
function testEmitsEventOnEntrance() public {
	vm.prank(PLAYER);
	vm.expectEmit(true, false, false, false, address(raffle));
	emit EnteredRaffle(PLAYER);
	raffle.enterRaffle{value: entranceFee}();
}
```
#### ``vm.roll`` and ``vm.warp``
- [``vm.warp``](https://book.getfoundry.sh/cheatcodes/warp?highlight=warp#warp)
- [``vm.roll``](https://book.getfoundry.sh/cheatcodes/roll?highlight=roll#roll)
- When working on a forked chain or a local chain, we can set the blocktime and blocknumber to whatever we want
	- ``vm.warp(block.timestamp + interval + 1);``
	- ``vm.roll(block.number + 1);``
```solidity
function testCantEnterWhenRaffleIsCalculating() public {
	vm.prank(PLAYER);
	raffle.enterRaffle{value: entranceFee}();
	vm.warp(block.timestamp + interval + 1);
	vm.roll(block.number + 1);
	raffle.performUpkeep("");

	vm.expectRevert(Raffle.Raffle__RaffleNotOpen.selector);
	vm.prank(PLAYER);
	raffle.enterRaffle{value: entranceFee}();
}
```

#### Create Subscription Script
- If we don't already have a subscription with Chainlink, we need to create one
- ``cast sig "functionName()"
	- returns the hex signature of a function
- [openchain.xyz](https://openchain.xyz/)
- [eth signature database](https://openchain.xyz/signatures)
```
contract CreateSubscription is Script {
    function createSubscriptionUsingConfig() public returns (uint64) {
        HelperConfig helperConfig = new HelperConfig();
        (,, address vrfCoordinator,,,) = helperConfig.activeNetworkConfig();
        return createSubscription(vrfCoordinator);
    }

    function createSubscription(address vrfCoordinator) public returns(uint64) {
        console.log("Creating Subscription on chainId: ", block.chainid);
        vm.startBroadcast();
        uint64 subId = VRFCoordinatorV2Mock(vrfCoordinator).createSubscription();
        vm.stopBroadcast();
        console.log("Your subId is: ",subId);
        console.log("Please update subscriptionId in HelperConfig.s.sol");
        return subId;
    }

    function run() external returns(uint64) {
        return createSubscriptionUsingConfig();
    }
}
```

#### Create Subscription from the UI
https://vrf.chain.link/

#### Fund Subscription Script
- [Link Token](https://chain.link/)
	- Sepolia: ``0x779877A7B0D9E8603169DdbD7836e478b4624789``
- [Solmate](https://github.com/transmissions11/solmate)
	- Gas optimized building blocks for smart contracts
	- After installing, we updated ``foundry.toml``: ``remappings = ["@chainlink/contracts=lib/chainlink-brownie-contracts/contracts", "@solmate=lib/solmate/src"]``
- [Openzeppelin](https://www.openzeppelin.com/)
```solidity
contract FundSubscription is Script {
    uint96 public constant FUND_AMOUNT = 3 ether;

    function fundSubscriptionUsingConfig() public {
        HelperConfig helperConfig = new HelperConfig();
        (, , address vrfCoordinator, , uint64 subId, ,address link) = helperConfig.activeNetworkConfig();
        fundSubscription(vrfCoordinator, subId, link);
    }

    function fundSubscription(address vrfCoordinator, uint64 subId, address link) public {
        console.log("Funding subscription: ", subId);
        console.log("Using vrfCoordinator: ", vrfCoordinator);
        console.log("On ChainID: ", block.chainid);
        if (block.chainid == 31337) {
            vm.startBroadcast();
            VRFCoordinatorV2Mock(vrfCoordinator).fundSubscription(subId, FUND_AMOUNT);
            vm.stopBroadcast();
        } else {
            vm.startBroadcast();
            LinkToken(link).transferAndCall(vrfCoordinator, FUND_AMOUNT, abi.encode(subId));
            vm.stopBroadcast();
        }
    }
```


#### Add Consumer Script
- [foundry dev ops](https://github.com/Cyfrin/foundry-devops)
	- ``forge install Cyfrin/foundry-devops --no-commit``
- Usage
```js
import {DevOpsTools} from "lib/foundry-devops/src/DevOpsTools.sol";
import {MyContract} from "my-contract/MyContract.sol";
.
.
.
function interactWithPreviouslyDeployedContracts() public {
    address contractAddress = DevOpsTools.get_most_recent_deployment("MyContract", block.chainid);
    MyContract myContract = MyContract(contractAddress);
    myContract.doSomething();
}
```

```js
contract AddConsumer is Script {
    function addConsumer(address raffle, address vrfCoordinator, uint64 subId) public {
        console.log("Adding consumer contract: ", raffle);
        console.log("Using vrfCoordinator: ", vrfCoordinator);
        console.log("On ChainId: ", block.chainid);

        vm.startBroadcast();
        VRFCoordinatorV2Mock(vrfCoordinator).addConsumer(subId, raffle);
        vm.stopBroadcast();
    }

    function addConsumerUsingConfig(address raffle) public {
        HelperConfig helperConfig = new HelperConfig();
        (, , address vrfCoordinator, , uint64 subId, ,) = helperConfig.activeNetworkConfig();
        addConsumer(raffle, vrfCoordinator, subId);
    }



    function run() external {
        address raffle = DevOpsTools.get_most_recent_deployment("Raffle", block.chainid);
        addConsumerUsingConfig(raffle);
    }

}
```



#### CheckUpkeep Tests
```solidity
  function testCheckUpkeepReturnsFalseIfItHasNoBalance() public {
        // Arrange
        vm.warp(block.timestamp + interval +1);
        vm.roll(block.number + 1);

        // Act
        (bool upkeepNeeded, ) = raffle.checkUpkeep("");

        // Assert
        assert(!upkeepNeeded);
    }
```

- ``forge coverage --report debug``
	- Gives us an output of all the lines we haven't yet covered in our tests
- - ``forge coverage --report debug > coverage.txt``
	- Gives us a text file

```solidity
function testCheckUpkeepReturnFalseIfRaffleNotOpen() public {
        //Arrange
        vm.prank(PLAYER);
        raffle.enterRaffle{value:entranceFee}();
        vm.warp(block.timestamp + interval + 1);
        vm.roll(block.number + 1);
        raffle.performUpkeep("");

        // Act
        (bool upkeepNeeded, ) = raffle.checkUpkeep("");

        // Assert
        assert(upkeepNeeded == false);
    }

    function testCheckUpkeepReturnsFalseIfEnoughTimeHasntPassed() public {
        // Arrange
        vm.prank(PLAYER);
        raffle.enterRaffle{value:entranceFee}();

        // Act
        (bool timeHasPassed, ) = raffle.checkUpkeep("");

        // Assert
        assert(timeHasPassed == false);
    }

    function testCheckUpkeepReturnsTrueWhenParametersAreGood() public {
        // Arrange
        vm.prank(PLAYER);
        raffle.enterRaffle{value:entranceFee}();
        vm.warp(block.timestamp + interval + 1);
        vm.roll(block.number + 1);

        // Act
        (bool upkeepNeeded, ) = raffle.checkUpkeep("");

        // Assert
        assert(upkeepNeeded == true);
    }
```


#### PerformUpkeep Tests
- There is no test for "expect not revert", so we can just run the function:
```
function testPerformUpkeepCanOnlyRunIfCheckUpkeepIsTrue() public {
        // Arrange
        vm.prank(PLAYER);
        raffle.enterRaffle{value:entranceFee}();
        vm.warp(block.timestamp + interval + 1);
        vm.roll(block.number + 1);

        // Act/Asser
        raffle.performUpkeep("");
    }
```

- We can use[ ``vm.expectRevert();``](https://book.getfoundry.sh/cheatcodes/expect-revert) if we expect a fail
- If a revert message doesn't have any parameters, we could do:
	- ``vm.expectRevert(Raffle.Raffle__UpkeepNotNeeded.selector)``
- If a revert message does have parameters:
	- ``vm.expectRevert(abi.encodeWithSelector(Raffle.Raffle__UpkeepNotNeeded.selector, currentBalance, numPlayers, raffleState));``

#### Getting Event Data Into Foundry Scripts
- Events are not accessible by smart contracts
	- But we can access them in our tests
- [`vm.recordLogs`](https://book.getfoundry.sh/cheatcodes/record-logs?highlight=Vm.Log%5B%5D#examples)
	- Tells vm to start recording all emitted events
	- Automatically saves all log outputs into a data structure that we can view
- ``Vm.Log[]``
	- a special type that comes with foundry tests
	- ``import {Vm} from "forge-std/Vm.sol";``
	- ``Vm.Log[] memory entries = vm.getRecordedLogs();``
- `bytes32 requestId = entries[1].topics[1];`
	- The 0 index topic will refer to the entire event
	- The 1 index topic will refer to the first parameter

#### Intro To Fuzz Tests
- [Fuzz Testing](https://book.getfoundry.sh/forge/fuzz-testing?highlight=fuzz#fuzz-testing)
	- Testing general scenarios rather than isolated scenarios
```solidity
function fulfillRandomWordsCanOnlyBeCalledAfterPerformUpkeep(uint256 randomRequestId) public raffleEnteredAndTimePassed {
        // Arrange
        vm.expectRevert("nonexistent request");
        VRFCoordinatorV2Mock(vrfCoordinator).fulfillRandomWords(randomRequestId, address(raffle));
    }
```
- Using the ``randomRequestId`` parameter, foundry will call the test many times with many random numbers

#### One Big Test
- [vm.hoax](https://book.getfoundry.sh/reference/forge-std/hoax?highlight=hoax#hoax)
	- The equivalent of running prank/deal
```
 function testFulfillRandomWordsPicksARandomWinnerAndSendsMoney() public raffleEnteredAndTimePassed {
        // Arrange
        uint256 additionalEntrants = 5;
        uint256 startingIndex = 1;

        for (uint256 i = startingIndex; i < startingIndex + additionalEntrants; i++){
            address player = address(uint160(i));
            hoax(player, STARTING_USER_BALANCE);
            raffle.enterRaffle{value: entranceFee}();
        }

        uint256 prize = entranceFee + (additionalEntrants + 1);

        vm.recordLogs();
        raffle.performUpkeep(""); //emit requestId
        Vm.Log[] memory entries = vm.getRecordedLogs();
        bytes32 requestId = entries[1].topics[1];

        uint256 previousTimestamp = raffle.getLastTimeStamp();

        // pretend to be chainlink vrf to get random number and pick winner
        VRFCoordinatorV2Mock(vrfCoordinator).fulfillRandomWords(uint256(requestId), address(raffle));

        // vm.expectEmit(true, false, false, false, address(raffle));
        // emit PickedWinner(address);

        // Assert
        assert(uint256(raffle.getRaffleState()) == 0);
        assert(raffle.getRecentWinner() != address(0));
        assert(raffle.getLengthOfPlayers() == 0);
        assert(previousTimestamp < raffle.getLastTimeStamp());
        assert(raffle.getRecentWinner().balance == STARTING_USER_BALANCE + prize);
    }
```
- It's not great practice to have many asserts in a single test
	- Best practice to have 1 assert per test

#### Passing the private key to vm.startBroadcast
- `addConsumer` fails when we try to run a forked url because of the wrong test key
	- we have to pretend to be the `addConsumer`
	- we can't use ``vm.prank`` in our deploy script
	- instead, we can pass in a private key in ``vm.startBroadcast()``
- [`envUint`](https://book.getfoundry.sh/cheatcodes/env-uint?highlight=envU#envuint)
	- a cheatcode that allows us to use env variables
	 - ``vm.envUint("PRIVATE_KEY");``
- `forge test --fork-url $SEPOLIA_RPC_URL`
 - Some tests may not work because of the way certain things are handled on chain vs local environment
```js
 modifier skipFork() {
        if (block.chainid != 31337) {
            return;
        }
        _;
    }
```
- we can add a modifier to skip certain tests when running `--fork-url`
- `forge coverage --report`
	- to see exactly what we don't have tests for

#### Integrations Test
- Foundry is ideal for testing on chain
	- When off chain interactions like Chainlink VRF are involved, it makes staging tests a lot more complicated

#### Testnet Demo Makefile Setup
```make
-include .env

.PHONY: all test deploy

help:
    @echo "Usage:"
    @echo " make deploy [ARGS=...]"

build:; forge build
```

- `build:; forge build` using the semicolon is the equivalent of putting `forge build` on a new line
- View: Toggle Word Wrap (`Alt + Z`)

#### Testnet Demo
- `make deploy ARGS="--network sepolia"`
- We can interact with the contract on etherscan
- `cast`
	- We can use cast to interact with the contract from the cli
	- `$ cast call 0xD7158A68e91ad5db172843460105e3B1e0c0f3d6 "getEntraceFee()" --rpc-url $SEPOLIA_RPC_URL`

#### `console.log` debugging
- Don't forget to delete you console.log before deploying to mainnet or testnet
- `console.log` will cost/spend gas

#### `forge test --debug`
- We can get the opcodes of our contract


### [Lesson 10 Foundry ERC20](https://www.youtube.com/watch?v=sas02qSFZ74&t=25684s)
#### What is an ERC20? What is an EIP?
- [EIP](https://eips.ethereum.org/)
	- Ethereum Improvement Proposal
	- Ideas to improve Ethereum
	- Improvements can be anything from a core blockchain update to some standard that is going to be a best practice for the entire community to adopt
- Once an EIP gets enough insight, an [ERC](https://eips.ethereum.org/erc) is created
	- Ethereum Request for Comments
#### What is an ERC20?
- [ERC20](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)
	- A token standard for smart contracts
	- ERC20s are tokens that are deployed an a chain using the ERC20 token standard
	- A smart contract that represents a token
- Why make an ERC20?
	- governance token
	- secure an underlying network
	- create a synthetic asset

#### Manual Token
- In order to implement our own ERC20, all we have to do is follow the ERC20 standard
- Holding tokens in an ERC20 just means you have some balance in some mapping
	- ``mapping(address=>uint256) private s_balances;``

#### ERC20 Token Openzeppelin
- [Openzeppelin Wizard](https://wizard.openzeppelin.com/)
- [Openzeppelin Contracts](https://docs.openzeppelin.com/contracts/5.x/)
- [Openzeppelin Github](https://github.com/OpenZeppelin)
	- [contracts](https://github.com/OpenZeppelin/openzeppelin-contracts)
- Install openzeppelin contracts
	- `forge install OpenZeppelin/openzeppelin-contracts --no-git`
	- update toml: `remappings = ['@openzeppelin=lib/openzeppelin-contracts']`
	 - `import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";`
- If we inherit a contract that has a constructor, then our contract needs a constructor
- [Solmate](https://github.com/transmissions11/solmate) (Openzeppelin alternative)

#### Deploy Script
```solidity
//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import {Script} from "forge-std/Script.sol";
import {OurToken} from "../src/OurToken.sol";

contract DeployOurToken is Script {
    uint256 public constant INITIAL_SUPPLY = 1000 ether;

    function run() external {
        vm.startBroadcast();
        new OurToken(INITIAL_SUPPLY);
        vm.stopBroadcast();
    }
}
```

#### AI Tests
- `transferFrom(address from, address to, uint256 amount) → bool`
	- Moves `amount` tokens from `from` to `to` using the allowance mechanism. `amount` is then deducted from the caller’s allowance.
	- This is usually the reason you have to "approve" when interacting with defi
- [etherscan token approval](https://etherscan.io/tokenapprovalchecker)
- chatgpt prompt

Here is my solidity ERC20 token.

```
// contracts/OurToken.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract OurToken is ERC20 {
    constructor(uint256 initialSupply) ERC20("OurToken", "OT") {
        _mint(msg.sender, initialSupply);
    }
}
```

And here our my first couple of tests written in solidity.

```
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.19;

import {DeployOurToken} from "../script/DeployOurToken.s.sol";
import {OurToken} from "../src/OurToken.sol";
import {Test, console} from "forge-std/Test.sol";
import {StdCheats} from "forge-std/StdCheats.sol";

interface MintableToken {
    function mint(address, uint256) external;
}

contract OurTokenTest is StdCheats, Test {
    OurToken public ourToken;
    DeployOurToken public deployer;

    function setUp() public {
        deployer = new DeployOurToken();
        ourToken = deployer.run();
    }

    function testInitialSupply() public {
        assertEq(ourToken.totalSupply(), deployer.INITIAL_SUPPLY());
    }

    function testUsersCantMint() public {
        vm.expectRevert();
        MintableToken(address(ourToken)).mint(address(this), 1);
    }
}
```

Can you write the rest of the tests? Please include tests for:

- Allowances
- transfers
- anything else that might be important

### [Lesson 11 Foundry NFTs](https://www.youtube.com/watch?v=sas02qSFZ74&t=27656s)
#### What is an NFT?
- ERC721 token standard created on the Ethereum platform
- Non fungible token
	- A token isn't interchangeable with any other token in its class
- [EIP 721](https://eips.ethereum.org/EIPS/eip-721)
	- NFT standard
- [EIP 1155]
	- Multi token standard
	- Semi fungible tokens
- ERC20s have map address to amounts tracking balances
```solidity
contract ERC20 is Context, IERC20 {
	mapping (address => uint256) private _balances;
}
```
- ERC721s have unique token IDs
	- each token id represents a unique asset
```solidity
mapping (uint256 => address) private _owners;
```

- [URI](https://www.techtarget.com/whatis/definition/URI-Uniform-Resource-Identifier): Uniform resources identifier
	- A Uniform Resource Identifier (URI) is a character sequence that identifies a logical (abstract) or physical resource -- usually, but not always, connected to the internet. A URI distinguishes one resource from another.
	- URL and URN aret types of URI
	- a tokenURI is just a simple API call
	- the image URI is a separate uri that points to an image
```json
{
	"name": "Name",
	"description": "Description",
	"image": "URI",
	"attributes": []
}
```
- Basic process dealing with metadata/uri
	1. Get [IPFS](https://ipfs.tech/)or some form of hosting
	2. Add tokenURI json to IPFS
	3. Add IPFS URI to your NFT URI

#### Foundry Setup
- `forge init --no-commit`
- [OpenZeppelin contracts](https://github.com/OpenZeppelin/openzeppelin-contracts)
	- `forge install OpenZeppelin/openzeppelin-contracts`
	- Add `@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/` in `remappings.txt.`
	- `forge remappings > remappings.txt`
- Start of contract:
```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import {ERC721} from "@openzeppelin/contracts/token/ERC721/ERC721.sol";

contract BasicNft is ERC721 {
    constructor() ERC721("DoggieNft", "DOG") {}
}
```

- Metadata
```solidity
/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension
/// @dev See https://eips.ethereum.org/EIPS/eip-721
///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.
interface ERC721Metadata /* is ERC721 */ {
    /// @notice A descriptive name for a collection of NFTs in this contract
    function name() external view returns (string _name);

    /// @notice An abbreviated name for NFTs in this contract
    function symbol() external view returns (string _symbol);

    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.
    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC
    ///  3986. The URI may point to a JSON file that conforms to the "ERC721
    ///  Metadata JSON Schema".
    function tokenURI(uint256 _tokenId) external view returns (string);
}
```

- URL vs URI
	- A URL provides the location of a resource
	- A URI identifies the resource by the name of the specified location or URL
- `function tokenURI(uint256 _tokenId) external view returns (string);`
	- Basically an api that points to where the NFT metadata is hosted
```solidity
function tokenURI(uint256 tokenId) public view virtual returns (string memory) {
        _requireOwned(tokenId);
        string memory baseURI = _baseURI();
        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";
    }
```

#### IPFS
- [Docs](https://docs.ipfs.tech/)
	- The InterPlanetary File System (IPFS) is a set of composable, peer-to-peer protocols for addressing, routing, and transferring [content-addressed](https://docs.ipfs.tech/concepts/glossary/#content-addressing) data in a decentralized file system.
- IPFS hashes our data 
	- The IPFS node performs the hashing, and all nodes have the same hashing function
	- That hash is then hosted, and there are many nodes running
- IPFS is decentralized storage
	- It cannot execute smart contracts
- [Install desktop app](https://docs.ipfs.tech/install/ipfs-desktop/)
- [Browser Extenson](https://docs.ipfs.tech/install/ipfs-companion/)

#### Using IPFS
- ipfs.io
	- `https://ipfs.io/ipfs/...`
	- Points to the website, so if site goes down, the token uri won't be hosted
- ipfs/hash
	- `ipfs://....`
	- If the syntax doesn't have io, its pointing to the ipfs network

```solidity
    function mintNft(string memory tokenUri) public {
        s_tokenIdToUri[s_tokenCounter] = tokenUri;
        _safeMint(msg.sender, s_tokenCounter);
        s_tokenCounter++;
    }

    function tokenURI(
        uint256 tokenId
    ) public view override returns (string memory) {
        return s_tokenIdToUri[tokenId];
    }
```

#### BasicNFT Deploy Script
```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import {Script} from "forge-std/Script.sol";
import {BasicNft} from "../src/BasicNft.sol";

contract DeployBasicNft is Script {
    function run() external returns (BasicNft) {
        vm.startBroadcast();
        BasicNft basicNft = new BasicNft();
        vm.stopBroadcast();
        return basicNft;
    }
}
```

#### BasicNFT Tests
- Strings are a special type
	- Strings are an array of bytes
	- We can't compare arrays to arrays
	- We can only compare primitive types like uint256, bool, address, bytes32
- Rather than loop through the array to compare, we can compare hashes
	- `bytes memory encodedDog = abi.encodePacked(dog)`;
		- encodedDog  //Type: dynamic bytes
	- `bytes32 dogHash = keccak256(encodedDog)`
		- dogHas  //Type: bytes32

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import {Test} from "forge-std/Test.sol";
import {DeployBasicNft} from "../script/DeployBasicNft.s.sol";
import {BasicNft} from "../src/BasicNft.sol";

contract BasicNftTest is Test {
    DeployBasicNft public deployer;
    BasicNft public basicNft;
    string public constant MAYHEM =
        "https://ipfs.io/ipfs/QmNuiupUrGodFC5bvW5c5rRY2SBfEbDBhe52vdXr7UKcFa?filename=goodBoy.json";
    address public USER = makeAddr("user");

    function setUp() public {
        deployer = new DeployBasicNft();
        basicNft = deployer.run();
    }

    function testNameIsCorrect() public view {
        string memory expectedName = "Pooch";
        string memory actualName = basicNft.name();
        assert(
            keccak256(abi.encodePacked(expectedName)) ==
                keccak256(abi.encodePacked(actualName))
        );
    }

    function testCanMintAndHaveABalance() public {
        vm.prank(USER);
        basicNft.mintNft(MAYHEM);
  
        assert(basicNft.balanceOf(USER) == 1);
        assert(
            keccak256(abi.encodePacked(MAYHEM)) ==
                keccak256(abi.encodePacked(basicNft.tokenURI(0)))
        );
    }
}
```
- We can use `chisel` to get more information about variables through the console.
```
➜ string memory dog = "dog"
➜ string memory cat = "cat";
➜ cat
Type: string
├ UTF-8: cat
├ Hex (Memory):
├─ Length ([0x00:0x20]): 0x0000000000000000000000000000000000000000000000000000000000000003
├─ Contents ([0x20:..]): 0x6361740000000000000000000000000000000000000000000000000000000000
├ Hex (Tuple Encoded):
├─ Pointer ([0x00:0x20]): 0x0000000000000000000000000000000000000000000000000000000000000020
├─ Length ([0x20:0x40]): 0x0000000000000000000000000000000000000000000000000000000000000003
└─ Contents ([0x40:..]): 0x6361740000000000000000000000000000000000000000000000000000000000
```

#### BasicNFT Interactions
```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import {Script} from "forge-std/Script.sol";
import {DevOpsTools} from "@foundry-devops/src/DevOpsTools.sol";
import {BasicNft} from "../src/BasicNft.sol";

contract MintBasicNft is Script {
    string public constant MAYHEM =
        "https://ipfs.io/ipfs/QmNuiupUrGodFC5bvW5c5rRY2SBfEbDBhe52vdXr7UKcFa?filename=goodBoy.json";
    address public USER = makeAddr("user");

    function run() external {
        address mostRecentlyDeployed = DevOpsTools.get_most_recent_deployment(
            "BasicNft",
            block.chainid
        );
        mintNftOnContract(mostRecentlyDeployed);
    }

    function mintNftOnContract(address contractAddress) public {
        vm.startBroadcast();
        BasicNft(contractAddress).mintNft(MAYHEM);
        vm.stopBroadcast();
    }
}
```
- `forge install Cyfrin/foundry-devops --no-commit`

#### BasicNFT Testnet Demo
```make
-include .env

.PHONY: all test clean deploy fund help install snapshot format anvil

DEFAULT_ANVIL_KEY := 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80 

help:
    @echo "Usage:"
    @echo "  make deploy [ARGS=...]\n    example: make deploy ARGS=\"--network sepolia\""
    @echo ""
    @echo "  make fund [ARGS=...]\n    example: make deploy ARGS=\"--network sepolia\""

all: clean remove install update build

# Clean the repo
clean  :; forge clean

# Remove modules
remove :; rm -rf .gitmodules && rm -rf .git/modules/* && rm -rf lib && touch .gitmodules && git add . && git commit -m "modules"

install :; forge install Cyfrin/foundry-devops@0.0.11 --no-commit && forge install foundry-rs/forge-std@v1.5.3 --no-commit && forge install openzeppelin/openzeppelin-contracts@v4.8.3 --no-commit

# Update Dependencies
update:; forge update

build:; forge build

test :; forge test

snapshot :; forge snapshot

format :; forge fmt

anvil :; anvil -m 'test test test test test test test test test test test junk' --steps-tracing --block-time 1

NETWORK_ARGS := --rpc-url http://localhost:8545 --private-key $(DEFAULT_ANVIL_KEY) --broadcast

ifeq ($(findstring --network sepolia,$(ARGS)),--network sepolia)
    NETWORK_ARGS := --rpc-url $(SEPOLIA_RPC_URL) --private-key $(PRIVATE_KEY) --broadcast --verify --etherscan-api-key $(ETHERSCAN_API_KEY) -vvvv
endif

deploy:
    @forge script script/DeployBasicNft.s.sol:DeployBasicNft $(NETWORK_ARGS)

mint:
    @forge script script/Interactions.s.sol:MintBasicNFT ${NETWORK_ARGS}
```

- `make deploy ARGS="--network sepolia"`

```
address mostRecentlyDeployed = DevOpsTools.get_most_recent_deployment(
            "BasicNft",
            block.chainid
        );
```
- This didn't work for me. I need to install [jq???](https://github.com/Cyfrin/foundry-full-course-f23/discussions/712)... so I just hard coded the address

#### The issue with IPFS and HTTPS TokenURI NFTs
- If a website goes down, the link to the image is gone
- When using IPFS, we can pin our data to our node
- [pinata](https://pinata.cloud/)
	- A pinning service that we can allow someone node other than our node to pin

#### What is an SVG
- [svg](https://www.w3schools.com/graphics/svg_intro.asp)
	- scalable vector graphics
- [vscode extension](https://marketplace.visualstudio.com/items?itemName=vitaliymaz.vscode-svg-previewer)
- [base64 encoding](https://www.base64encode.org/)
```bash
base64 -i example.svg
PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1MDAiIGhlaWdo
dD0iNTAwIj4NCjx0ZXh0IHg9IjAiIHk9IjE1IiBmaWxsPSJibGFjayI+VW5ndXMgQnVuZ3VzPC90
ZXh0Pg0KPC9zdmc+
```
```
// svg.txt
data:image/svg+xml;base64,
PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1MDAiIGhlaWdo
dD0iNTAwIj4NCjx0ZXh0IHg9IjAiIHk9IjE1IiBmaWxsPSJibGFjayI+VW5ndXMgQnVuZ3VzPC90
ZXh0Pg0KPC9zdmc+
```

```svg
<svg viewBox="0 0 200 200" width="400"  height="400" xmlns="http://www.w3.org/2000/svg">
  <circle cx="100" cy="100" fill="purple" r="78" stroke="black" stroke-width="3"/>
  <g class="eyes">
    <circle cx="61" cy="82" r="15" stroke="black" stroke-width="6" fill="blue"/>
    <circle cx="127" cy="82" r="15" stroke="black" stroke-width="6" fill="blue"/>
  </g>
  <path d="m136.71 115.53c.69 26.17-64.11 52-91.01.73" style="fill:black; stroke: black; stroke-width: 6;"/>
</svg>
```

```bash
base64 -i happy.svg
PHN2ZyB2aWV3Qm94PSIwIDAgMjAwIDIwMCIgd2lkdGg9IjQwMCIgIGhlaWdodD0iNDAwIiB4bWxu
cz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPg0KICA8Y2lyY2xlIGN4PSIxMDAiIGN5PSIx
MDAiIGZpbGw9InB1cnBsZSIgcj0iNzgiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMyIv
Pg0KICA8ZyBjbGFzcz0iZXllcyI+DQogICAgPGNpcmNsZSBjeD0iNjEiIGN5PSI4MiIgcj0iMTUi
IHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iNiIgZmlsbD0iYmx1ZSIvPg0KICAgIDxjaXJj
bGUgY3g9IjEyNyIgY3k9IjgyIiByPSIxNSIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSI2
IiBmaWxsPSJibHVlIi8+DQogIDwvZz4NCiAgPHBhdGggZD0ibTEzNi43MSAxMTUuNTNjLjY5IDI2
LjE3LTY0LjExIDUyLTkxLjAxLjczIiBzdHlsZT0iZmlsbDpibGFjazsgc3Ryb2tlOiBibGFjazsg
c3Ryb2tlLXdpZHRoOiA2OyIvPg0KPC9zdmc+
```

- We can use svg on chain by using the base64 encoding as tokenUri

#### SVG NFT Introduction
```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import {ERC721} from "@openzeppelin/contracts/token/ERC721/ERC721.sol";
  
contract BasicNft is ERC721 {
    uint256 private s_tokenCounter;
    string private s_happySvg;
    string private s_sadSvg;

    constructor(
        string memory happySvg,
        string memory sadSvg
    ) ERC721("Mood NFT", "MN") {
        s_tokenCounter = 0;
        s_happySvg = happySvg;
        s_sadSvg = sadSvg;
    }

    function mintNft() public {
        _safeMint(msg.sender,s_tokenCounter);
        s_tokenCounter++;
    }

    function tokenURI(uint256 tokenId) public view override returns (string memory) {}
}
```

#### Encoding the NFT
- [base64 openzeppelin](https://docs.openzeppelin.com/contracts/4.x/utilities)
- `base64 -i <filename>`
	- this command will give an output like below
```
PHN2ZyB2aWV3Qm94PSIwIDAgMjAwIDIwMCIgd2lkdGg9IjQwMCIgIGhlaWdodD0iNDAwIiB4bWxu
cz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPg0KICA8Y2lyY2xlIGN4PSIxMDAiIGN5PSIx
MDAiIGZpbGw9InB1cnBsZSIgcj0iNzgiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMyIv
Pg0KICA8ZyBjbGFzcz0iZXllcyI+DQogICAgPGNpcmNsZSBjeD0iNjEiIGN5PSI4MiIgcj0iMTUi
IHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iNiIgZmlsbD0iYmx1ZSIvPg0KICAgIDxjaXJj
bGUgY3g9IjEyNyIgY3k9IjgyIiByPSIxNSIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSI2
IiBmaWxsPSJibHVlIi8+DQogIDwvZz4NCiAgPHBhdGggZD0ibTE0Ni4wMSAxMTUuNTNjLjY5IDI2
LjE3LTU0LjExIDkwLTEwMC4wMS4wIiBzdHlsZT0iZmlsbDpibGFjazsgc3Ryb2tlOiBibGFjazsg
c3Ryb2tlLXdpZHRoOiA2OyIvPg0KPC9zdmc+
```
- prepend the above with `data:image/svg+xml;base64,`
- OpenZeppelin Base64 allows us to encode on chain
```
function _baseURI() internal pure override returns (string memory) {
        return "data:application/json;base64,";
    }

    function tokenURI(
        uint256 tokenId
    ) public view override returns (string memory) {
        string memory imageUri;

        if (s_tokenIdToMood[tokenId] == Mood.HAPPY) {
            imageUri = s_happySvgImageUri;
        } else {
            imageUri = s_sadSvgImageUri;
        }

        return
            string(
                abi.encodePacked(
                    _baseURI(),
                    Base64.encode(
                        bytes(
                            abi.encodePacked(
                                '{"name": "',
                                name(),
                                '", "description":"An nft that reflects mood", "attributes":[{"trait_type": "moodiness", "value": 100}],"image": "',
                                imageUri,
                                '"}'
                            )
                        )
                    )
                )
            );
    }
```

9:01:35

#### Flipping the Mood
```solidity
 function flipMood(uint256 tokenId) public {
        address from = _ownerOf(tokenId);
        _checkAuthorized(from, msg.sender, tokenId);

        if (s_tokenIdToMood[tokenId] == Mood.HAPPY) {
            s_tokenIdToMood[tokenId] = Mood.SAD;
        } else {
            s_tokenIdToMood[tokenId] = Mood.HAPPY;
        }
    }
```

This seems to be deprecated, replaced it with `_ownerOf` and `_checkAuthorized`
```solidity
if (!_isApprovedOrOwner(msg.sender, tokenId))
```

#### SVG NFT Deploy Script
- [readfile github issue](https://github.com/foundry-rs/foundry/issues/2153)
- [foundry book file cheat codes](https://book.getfoundry.sh/cheatcodes/fs?highlight=readFile#signature)
```solidity
// Reads the entire content of file to string, (path) => (data)
function readFile(string calldata) external returns (string memory);
```
- add to `foundry.toml`:
	- `fs_permissions = [{ access = "read", path = "./images/" }]`

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import {Script, console} from "forge-std/Script.sol";
import {MoodNft} from "../src/MoodNft.sol";
import {Base64} from "@openzeppelin/contracts/utils/Base64.sol";

contract DeployMoodNft is Script {
    function run() external returns (MoodNft) {
        string memory sadSvg = vm.readFile("./image/sad.svg");
        string memory happySvg = vm.readFile("./image/happy.svg");
        
        vm.startBroadcast();
        MoodNft moodNft = new MoodNft(svgToUri(happySvg), svgToUri(sadSvg));
        vm.stopBroadcast();

        return moodNft;
    }

    function svgToUri(string memory svg) public pure returns (string memory) {
        string memory baseURL = "data:image/svg+xml;base64,";
        string memory svgBase64Encoded = Base64.encode(
            bytes(string(abi.encodePacked(svg)))
        );

        return string(abi.encodePacked(baseURL, svgBase64Encoded));
    }
}
```

- Unit vs Integration test
	- Unit test is more for a single idea whereas an integration test can involve multiple aspects of a contract

#### SVG NFT Debugging practice
```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import {Test, console} from "forge-std/Test.sol";
import {MoodNft} from "../../src/MoodNft.sol";
import {DeployMoodNft} from "../../script/DeployMoodNft.s.sol";

contract MoodNftIntegrationTest is Test {
    MoodNft moodNft;

    string public constant HAPPY_SVG_IMAGE_URI =
        "data:image/svg+xml;base64, PHN2ZyB2aWV3Qm94PSIwIDAgMjAwIDIwMCIgd2lkdGg9IjQwMCIgIGhlaWdodD0iNDAwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPg0KICA8Y2lyY2xlIGN4PSIxMDAiIGN5PSIxMDAiIGZpbGw9InB1cnBsZSIgcj0iNzgiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMyIvPg0KICA8ZyBjbGFzcz0iZXllcyI+DQogICAgPGNpcmNsZSBjeD0iNjEiIGN5PSI4MiIgcj0iMTUiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iNiIgZmlsbD0iYmx1ZSIvPg0KICAgIDxjaXJjbGUgY3g9IjEyNyIgY3k9IjgyIiByPSIxNSIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSI2IiBmaWxsPSJibHVlIi8+DQogIDwvZz4NCiAgPHBhdGggZD0ibTE0Ni4wMSAxMTUuNTNjLjY5IDI2LjE3LTU0LjExIDkwLTEwMC4wMS4wIiBzdHlsZT0iZmlsbDpibGFjazsgc3Ryb2tlOiBibGFjazsgc3Ryb2tlLXdpZHRoOiA2OyIvPg0KPC9zdmc+";

    string public constant SAD_SVG_IMAGE_URI =
"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNHB4IiBoZWlnaHQ9IjEwMjRweCIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4NCiAgPHBhdGggZmlsbD0iIzMzMyIgZD0iTTUxMiA2NEMyNjQuNiA2NCA2NCAyNjQuNiA2NCA1MTJzMjAwLjYgNDQ4IDQ0OCA0NDggNDQ4LTIwMC42IDQ0OC00NDhTNzU5LjQgNjQgNTEyIDY0em0wIDgyMGMtMjA1LjQgMC0zNzItMTY2LjYtMzcyLTM3MnMxNjYuNi0zNzIgMzcyLTM3MiAzNzIgMTY2LjYgMzcyIDM3Mi0xNjYuNiAzNzItMzcyIDM3MnoiLz4NCiAgPHBhdGggZmlsbD0iI0U2RTZFNiIgZD0iTTUxMiAxNDBjLTIwNS40IDAtMzcyIDE2Ni42LTM3MiAzNzJzMTY2LjYgMzcyIDM3MiAzNzIgMzcyLTE2Ni42IDM3Mi0zNzItMTY2LjYtMzcyLTM3Mi0zNzJ6TTI4OCA0MjFhNDguMDEgNDguMDEgMCAwIDEgOTYgMCA0OC4wMSA0OC4wMSAwIDAgMS05NiAwem0zNzYgMjcyaC00OC4xYy00LjIgMC03LjgtMy4yLTguMS03LjRDNjA0IDYzNi4xIDU2Mi41IDU5NyA1MTIgNTk3cy05Mi4xIDM5LjEtOTUuOCA4OC42Yy0uMyA0LjItMy45IDcuNC04LjEgNy40SDM2MGE4IDggMCAwIDEtOC04LjRjNC40LTg0LjMgNzQuNS0xNTEuNiAxNjAtMTUxLjZzMTU1LjYgNjcuMyAxNjAgMTUxLjZhOCA4IDAgMCAxLTggOC40em0yNC0yMjRhNDguMDEgNDguMDEgMCAwIDEgMC05NiA0OC4wMSA0OC4wMSAwIDAgMSAwIDk2eiIvPg0KICA8cGF0aCBmaWxsPSIjMzMzIiBkPSJNMjg4IDQyMWE0OCA0OCAwIDEgMCA5NiAwIDQ4IDQ4IDAgMSAwLTk2IDB6bTIyNCAxMTJjLTg1LjUgMC0xNTUuNiA2Ny4zLTE2MCAxNTEuNmE4IDggMCAwIDAgOCA4LjRoNDguMWM0LjIgMCA3LjgtMy4yIDguMS03LjQgMy43LTQ5LjUgNDUuMy04OC42IDk1LjgtODguNnM5MiAzOS4xIDk1LjggODguNmMuMyA0LjIgMy45IDcuNCA4LjEgNy40SDY2NGE4IDggMCAwIDAgOC04LjRDNjY3LjYgNjAwLjMgNTk3LjUgNTMzIDUxMiA1MzN6bTEyOC0xMTJhNDggNDggMCAxIDAgOTYgMCA0OCA0OCAwIDEgMC05NiAweiIvPg0KPC9zdmc+";

    string public constant SAD_SVG_URI =        "data:application/json;base64,eyJuYW1lIjogIk1vb2QgTkZUIiwgImRlc2NyaXB0aW9uIjoiQW4gbmZ0IHRoYXQgcmVmbGVjdHMgbW9vZCIsICJhdHRyaWJ1dGVzIjpbeyJ0cmFpdF90eXBlIjogIm1vb2RpbmVzcyIsICJ2YWx1ZSI6IDEwMH1dLCJpbWFnZSI6ICJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVEF5TkhCNElpQm9aV2xuYUhROUlqRXdNalJ3ZUNJZ2RtbGxkMEp2ZUQwaU1DQXdJREV3TWpRZ01UQXlOQ0lnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JajROQ2lBZ1BIQmhkR2dnWm1sc2JEMGlJek16TXlJZ1pEMGlUVFV4TWlBMk5FTXlOalF1TmlBMk5DQTJOQ0F5TmpRdU5pQTJOQ0ExTVRKek1qQXdMallnTkRRNElEUTBPQ0EwTkRnZ05EUTRMVEl3TUM0MklEUTBPQzAwTkRoVE56VTVMalFnTmpRZ05URXlJRFkwZW0wd0lEZ3lNR010TWpBMUxqUWdNQzB6TnpJdE1UWTJMall0TXpjeUxUTTNNbk14TmpZdU5pMHpOeklnTXpjeUxUTTNNaUF6TnpJZ01UWTJMallnTXpjeUlETTNNaTB4TmpZdU5pQXpOekl0TXpjeUlETTNNbm9pTHo0TkNpQWdQSEJoZEdnZ1ptbHNiRDBpSTBVMlJUWkZOaUlnWkQwaVRUVXhNaUF4TkRCakxUSXdOUzQwSURBdE16Y3lJREUyTmk0MkxUTTNNaUF6TnpKek1UWTJMallnTXpjeUlETTNNaUF6TnpJZ016Y3lMVEUyTmk0MklETTNNaTB6TnpJdE1UWTJMall0TXpjeUxUTTNNaTB6TnpKNlRUSTRPQ0EwTWpGaE5EZ3VNREVnTkRndU1ERWdNQ0F3SURFZ09UWWdNQ0EwT0M0d01TQTBPQzR3TVNBd0lEQWdNUzA1TmlBd2VtMHpOellnTWpjeWFDMDBPQzR4WXkwMExqSWdNQzAzTGpndE15NHlMVGd1TVMwM0xqUkROakEwSURZek5pNHhJRFUyTWk0MUlEVTVOeUExTVRJZ05UazNjeTA1TWk0eElETTVMakV0T1RVdU9DQTRPQzQyWXkwdU15QTBMakl0TXk0NUlEY3VOQzA0TGpFZ055NDBTRE0yTUdFNElEZ2dNQ0F3SURFdE9DMDRMalJqTkM0MExUZzBMak1nTnpRdU5TMHhOVEV1TmlBeE5qQXRNVFV4TGpaek1UVTFMallnTmpjdU15QXhOakFnTVRVeExqWmhPQ0E0SURBZ01DQXhMVGdnT0M0MGVtMHlOQzB5TWpSaE5EZ3VNREVnTkRndU1ERWdNQ0F3SURFZ01DMDVOaUEwT0M0d01TQTBPQzR3TVNBd0lEQWdNU0F3SURrMmVpSXZQZzBLSUNBOGNHRjBhQ0JtYVd4c1BTSWpNek16SWlCa1BTSk5Namc0SURReU1XRTBPQ0EwT0NBd0lERWdNQ0E1TmlBd0lEUTRJRFE0SURBZ01TQXdMVGsySURCNmJUSXlOQ0F4TVRKakxUZzFMalVnTUMweE5UVXVOaUEyTnk0ekxURTJNQ0F4TlRFdU5tRTRJRGdnTUNBd0lEQWdPQ0E0TGpSb05EZ3VNV00wTGpJZ01DQTNMamd0TXk0eUlEZ3VNUzAzTGpRZ015NDNMVFE1TGpVZ05EVXVNeTA0T0M0MklEazFMamd0T0RndU5uTTVNaUF6T1M0eElEazFMamdnT0RndU5tTXVNeUEwTGpJZ015NDVJRGN1TkNBNExqRWdOeTQwU0RZMk5HRTRJRGdnTUNBd0lEQWdPQzA0TGpSRE5qWTNMallnTmpBd0xqTWdOVGszTGpVZ05UTXpJRFV4TWlBMU16TjZiVEV5T0MweE1USmhORGdnTkRnZ01DQXhJREFnT1RZZ01DQTBPQ0EwT0NBd0lERWdNQzA1TmlBd2VpSXZQZzBLUEM5emRtYysifQ==";
    
    DeployMoodNft deployer;
    address USER = makeAddr("user");

    function setUp() public {
        deployer = new DeployMoodNft();
        moodNft = deployer.run();
    }

    function testViewTokenUriIntegration() public {
        vm.prank(USER);
        moodNft.mintNft();
        console.log(moodNft.tokenURI(0));
    }

    function testFlipTokenToSad() public {
        vm.prank(USER);
        moodNft.mintNft();

		vm.prank(USER);
        moodNft.flipMood(0);

        console.log(moodNft.tokenURI(0));

        assertEq(
            keccak256(abi.encodePacked(moodNft.tokenURI(0))),
            keccak256(abi.encodePacked(SAD_SVG_URI))
        );
    }
}
```
- When running `source .env`, make sure it's in a bash terminal, not powershell

#### SVG NFT Anvil Demo
- make command:
```make
deployMood:
    @forge script script/DeployMoodNft.s.sol:DeployMoodNft ${NETWORK_ARGS}
```

- cast to mint nft
	- `cast send 0x5FbDB2315678afecb367f032d93F642f64180aa3 "mintNft()" --private-key ac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80 --rpc-url http://localhost:8545`

#### Filecoin and Arweave
- [nft.storage](https://nft.storage/)

#### EVM Opcodes, Encoding, and Calling
- [cheatsheet](https://docs.soliditylang.org/en/latest/cheatsheet.html#abi-encoding-and-decoding-functions)
- abi.encodePacked
	- globally available method
	- we can concatenate it convert it to a string since it's considered type bytes
	- `return string(abi.encodePacked("hi mom", "miss you"));`
	- as of `0.8.12`, we can :`string.concat(stringA, stringB)`
- When we compile a contract, we get a `.abi` and a `.bin` file
- Transactions have many fields: `nonce`, `gas price`, `gas limit`, `to`, `value`, `data`, `v,r,s`
	- `data` has the contract init code and contract bytecode
	- `bytecode` represents the low level computer instructions that allows the contract to exist
- [opcodes](https://www.evm.codes/?fork=shanghai)
	- The EVM represents all the instructions a computer must be able to read in order for it to interact with Ethereum or Ethereum like applications
	- Solidity compiles down to the bytecode that are these opcodes
- abi.encodePacked allows us to encode basically anything we want into binary format
- The contract abi that we look at when we compile a contract isn't the actual binary version of the contract
- `abi.encode(...) returns (bytes memory)`: [ABI](https://docs.soliditylang.org/en/latest/abi-spec.html#abi)-encodes the given arguments
- `abi.encodePacked(...) returns (bytes memory)`: Performs [packed encoding](https://docs.soliditylang.org/en/latest/abi-spec.html#abi-packed-mode) of the given arguments. Note that this encoding can be ambiguous!
- [openzeppelin difference between abi.encodepacked](https://forum.openzeppelin.com/t/difference-between-abi-encodepacked-string-and-bytes-string/11837)

- You'd use this to make calls to contracts:
```solidity
 function encodeString() public pure returns (bytes memory) {
	bytes memory someString = abi.encode("some string");
	return someString;
}
```
- returns:
```
bytes: 0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b736f6d6520737472696e67000000000000000000000000000000000000000000
```

- This is great if you want to save space, not good for calling functions.
- You can sort of think of it as a compressor for the massive bytes object above.
```solidity
  function encodeStringPacked() public pure returns (bytes memory) {
	bytes memory someString = abi.encodePacked("some string");
	return someString;
  }
```
- returns
```
bytes: 0x736f6d6520737472696e67
```

- `abi.encodePacked` is similar to type casting
```solidity
function encodeStringBytes() public pure returns (bytes memory) {
	bytes memory someString = bytes("some string");
	return someString;
}
```
- returns
```
bytes: 0x736f6d6520737472696e67
```

- We can also `decode`
- `abi.decode(bytes memory encodedData, (...)) returns (...)`: [ABI](https://docs.soliditylang.org/en/latest/abi-spec.html#abi)-decodes the provided data. The types are given in parentheses as second argument. Example: `(uint a, uint[2]`

- `multiEncodePacked`
```
function multiEncodePacked() public pure returns (bytes memory) {
	bytes memory someString = abi.encode("some string", "it's bigger");
	return someString;
}
```
- returns
```
bytes: 0x736f6d6520737472696e672069747320626967676572
```

- This function wouldn't work because solidity can't deal with things that are packed?
- `multidecodePacked`
```
function multiDecodePacked() public pure returns (string memory) {
	string memory someString = abi.decode(multiEncodePacked(), (string));
	return someString;
}
```

- but we can work with encoded data by type casting?
```
function multiStringCastPacked() public pure returns(string memory) {
	string memory someString = string(multiEncodePacked());
	return someString;
}
```

#### Encoding Function Calls Directly
- Transactions - Contract Deployment: 
	- `nonce`: tx count for the account
	- `gas price`: price per unit of gas (in wei)
	- `gas limit`: max gas that this tx can use
	- `to`: empty
	- `value`: amount of wei to send
	- `data`: contract init code and contract bytecode
	- `v,r,s`: components of tx signature
- Transactions - Function call: 
	- `nonce`: tx count for the account
	- `gas price`: price per unit of gas (in wei)
	- `gas limit`: max gas that this tx can use
	- `to`: address that the tx is sent to
	- `value`: amount of wei to send
	- `data`: what to send the to address
	- `v,r,s`: components of tx signature
- We know that transactions are going to be compiled down to binary/hex, so we can populate the data value of transactions ourselves

- To send a function we always need the ABI and the contract address

- `call`: How we call functions to change the state of the blockchain.
- `staticcall`: This is how (at a low level) we do our "view" or "pure" function calls, and potentially don't change the blockchain state.
	- When you call a function, you are secretly calling "call" behind the scenes, with everything compiled down to the binary stuff for you.

- example:
```
function withdraw(address recentWinner) public {
	(bool success, ) = recentWinner.call{value: address(this).balance}("");
	require(success, "Transfer Failed");
}
```
- In our `{} we were able to pass specific fields of a transaction, like value.
- In our `()` we were able to pass data in order to call a specific function - but there was no function we wanted to call!

- In order to call a function using only the data field of call, we need to encode:
	- The function name
	- The parameters we want to add
	- Down to the binary level

- To encode the function name, we need:
	- The "function selector": the first 4 bytes of the function signature
	- The "function signature": a string that defines the function name and parameters

- Example function signature:
	- `transfer(address,uint256)`
- Example function selector:
	- `0xa9059cbb`
- If we encode a function and take the first 4 bytes, we get the function selector

- `abi.encodeWithSelector`
	- Encodes the given arguments starting from the second and prepends the given four-bytes selector
- `abi.encodeWithSignature`
	- Equivalent to `abi.encodeWithSelector(bytes4(keccak256(bytes(signature)), ...)`

#### Verifying Metamask Transactions
- `cast --help`
	- `--calldata-decode`: Decode ABI-encoded input data
		- `<sig>`,`<calldata>`
- `cast sig "transferFrom(address,address,uint26)"` ---> `0x345dac5d`
- `https://openchain.xyz/signatures`



### [Lesson 12 Defi Stablecoin](https://www.youtube.com/watch?v=wUjYK5gwNZs&t=0s)
#### What is DeFi?
- [What is DeFi?](https://chain.link/education/defi)
- [DefiLlama](https://defillama.com/)
	- Gives a snapshot of the defi ecosystem on various chains
- [Bankless](https://www.bankless.com/)
- [MEV](https://www.flashbots.net/)
- [Aave](https://aave.com/)
- [My Previous Aave Video on Shorting Assets](https://www.youtube.com/watch?v=TmNGAvI-RUA)
- [DAI](https://makerdao.com/en/)
- [Uniswap](https://app.uniswap.org/)
- [Maximal Extractable Value (MEV)](https://ethereum.org/en/developers/docs/mev/)

#### Code Walkthrough
- There are two main contract files
	- `DSCEngine.sol`
	- `DecentralizedStablecoin.sol`
- `DSCEngine.sol` controls `DecentralizedStablecoin.sol`

#### Introduction to stablecoins
- A stable coin is a non volatile crypto asset
- [Video](https://www.youtube.com/watch?v=pciVQVocTYc)
- [MakerDAO Forums](https://start.makerdao.com/)

#### Details for Project
1. Relative Stability: Anchored or Pegged -> $1.00
    1. Chainlink price feed
    2. Set a function to exchange ETH and BTC
2. Stability Mechanism (Minting): Algorithmic (Decentralized)
    1. People can only  mint the stablecoin with enough collateral (coded)
3. Collateral: Exogenous (Crypto)
    1. wETH
    2. wBTC

#### Layout of Contract
```solidity
// Layout of Contract:
// version
// imports
// errors
// interfaces, libraries, contracts
// Type declarations
// State variables
// Events
// Modifiers
// Functions

// Layout of Functions:
// constructor
// receive function (if exists)
// fallback function (if exists)
// external
// public
// internal
// private
// view & pure functions
```

- Make code verbose to make it easier for auditors
- Install OpenZeppelin
```
forge install openzeppelin/openzeppelin-contracts --no-git
```
- Update remappings in `foundry.toml`
```
remappings = ["@openzeppelin/contracts=lib/openzeppelin-contracts/contracts"]
```
- and again for vscode
```
forge remappings > remappings.txt
```

- `ERC20Burnable` give us the `burn` function that helps maintain the peg price
```solidity
import {ERC20Burnable, ERC20} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol";

function burnFrom(address account, uint256 value) public virtual {
	_spendAllowance(account, _msgSender(), value);
	_burn(account, value);
}
```
- `ERC20Burnable` is `ERC20` so we have to add it to the constructor
```
contract DecentralizedStableCoin is ERC20Burnable {
    constructor()ERC20("DecentralizedStableCoin", "DSC") {}
}
```

- Indicates to use `burn` from parent class (`ERC20Burnable`)
```solidity
super.burn(_amount);
```

- Final code from this section... I had to add `Ownable(msg.sender)` to constructor to get rid compiler error:
```solidity
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.4;

import {ERC20Burnable, ERC20} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title DecentralizedStableCoin
 * @author Robin Punnoose
 * Collateral: Exogenous (ETH/BTC)
 * Minting: Algorithmic
 * Relative Stability: Pegged to USD
 *
 * This is the contract meant to be governed by DSCEngine. This contract is just the ERC20 implementation of our stablecoin system.
 *
 */

contract DecentralizedStableCoin is ERC20Burnable, Ownable {
    error DecentralizedStableCoin__MustBeMoreThanZero();
    error DecentralizedStableCoin__BurnAmountExceedBalance();
    error DecentralizedStableCoin__NotZeroAddress();

    constructor() ERC20("DecentralizedStableCoin", "DSC") Ownable(msg.sender) {}

    function burn(uint256 _amount) public override onlyOwner {
        uint256 balance = balanceOf(msg.sender);
        if (_amount <= 0) {
            revert DecentralizedStableCoin__MustBeMoreThanZero();
        }

        if (balance < _amount) {
            revert DecentralizedStableCoin__MustBeMoreThanZero();
        }
        super.burn(_amount);
    }

    function mint(
        address _to,
        uint256 _amount
    ) external onlyOwner returns (bool) {
        if (_to == address(0)) {
            revert DecentralizedStableCoin__BurnAmountExceedBalance();
        }

        if (_amount <= 0) {
            revert DecentralizedStableCoin__MustBeMoreThanZero();
        }
        
        _mint(_to, _amount);
        return true;
    }
}
```

#### Project setup - DSCEngine
- The `DSCEngine.sol` contract hold the main logic of the system
- We are going to set up a system where other users can liquidate users that are not over-collateralized
	- Users can pay back the debt to get the collateral

- Final code from this section `DSCEngine.sol`:
```solidity
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.4;

/**
 * @title DSCEngine
 * @author Robin Punnoose
 *
 * This system is designed to be as minimal as possible and have the tokens maintain a 1 token == $1 peg.
 * This stablecoin has the properties:
 * - Exogenous collateral
 * - Dollar pegged
 * - Algorithmically stable
 *
 * It is similar to DIA without the governance, does not require fees, and is collateralized only by wETH and wBTC
 *
 * Our DSC system should always be "overcollateralized". At no point should the value of all the collateral <= the $ backed value of all the DSC.
 *
 * @notice This contract is the core of the DSC System. It handles all the logic for minting and redeeming DSC, as well as depositing and withdrawing collateral.
 * @notice This contract is based on the MakerDAO DSS (DAI) system.
 */

contract DSCEngine {
    function depositCollateralAndMintDsc() external {}
  
    function depositCollateral() external {}

    function redeemCollateralForDsc() external {}

    function redeemCollateral() external {}

    function mindDsc() external {}

    function burnDsc() external {}

    function liquidate() external {}

    function getHealthFactor() external view {}
}
```

#### Create the deposit collateral function
- Other DeFi Examples:
    - [Aave V2 Docs](https://docs.aave.com/developers/v/2.0/)
    - [Aave NPM](https://www.npmjs.com/package/@aave/protocol-v2)

- updated constructor
```solidity
constructor(address[] memory tokenAddresses, address[] memory priceFeedAddresses, address dscAddress) {
	if (tokenAddresses.length != priceFeedAddresses.length) {
		revert DSCEngine__TokenAddressesAndPriceFeedAddressesMustBeSameLength();
	}

	for (uint256 i = 0; i < tokenAddresses.length; i++) {
		s_priceFeeds[tokenAddresses[i]] = priceFeedAddresses[i];
	}

	i_dsc = DecentralizedStableCoin(dscAddress);
}
```

- updated `depositCollateral` Function
```solidity
/**
 * @notice follows CEI pattern
 * @param tokenCollateralAddress The address of the token to deposit as collateral
 * @param amountCollateral The amount of collateral to deposit
 */

function depositCollateral(address tokenCollateralAddress, uint256 amountCollateral)
	external
	moreThanZero(amountCollateral)
	isAllowedToken(tokenCollateralAddress)
	nonReentrant
{
	s_collateralDeposited[msg.sender][tokenCollateralAddress] += amountCollateral;
	emit CollateralDeposited(msg.sender, tokenCollateralAddress, amountCollateral);
	bool success = IERC20(tokenCollateralAddress).transferFrom(msg.sender, address(this), amountCollateral);

	if (!success) {
		revert DSCEngine__TransferFailed();
	}
}
```

- added modifiers for input sanitation
```
    modifier moreThanZero(uint256 amount) {
        if (amount == 0) {
            revert DSCEngine__NeedsMoreThanZero();
        }
        _;
    }

    modifier isAllowedToken(address token) {
        if (s_priceFeeds[token] == address(0)) {
            revert DSCEngine__TokenNotAllowed();
        }
        _;
    }
```

- mapping to track tokens and price feeds
```
mapping(address token => address priceFeed) private s_priceFeeds;
```

- nested mapping to track collateral deposited by users:
```
mapping(address user => mapping(address token => uint256 amount)) private s_collateralDeposited;
```

- Reentrancies are one of the most common attacks in web3
	- adding nonReentrant from openzeppelin is more gas intensive, but it is safer
```solidity
import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
```

```solidity
contract DSCEngine is ReentrancyGuard
```

- allows us to use this modifier:
``nonReentrant``

- CEI Patterns
	- checks, effects, interactions

#### Creating the mint function
- [Aave Borrowing FAQs](https://docs.aave.com/faq/borrowing)
- [Health Factor](https://docs.aave.com/faq/borrowing#what-is-the-health-factor)
- [Aave Risk Parameters](https://docs.aave.com/risk/asset-risk/risk-parameters)
- `mintDsc`
	1.  check if collateral value > dsc amount (using a modifier)
```
/**
 *
 * @param amountDscToMint Amount of decentralized stable coin to be minted
 * @notice Must have more collateral value than the minimum threshold
 */

function mindDsc(uint256 amountDscToMint) external moreThanZero(amountDscToMint) nonReentrant {
	s_DSCMinted[msg.sender] += amountDscToMint;
	_revertIfHealthFactorIsBroken(msg.sender);
}
```

- `_revertIfHealthFactorIsBroken`
	1.  check health factor (do they have enough collateral)
	2. revert if they dont 

- `_healthFactor`
	1. need total dsc minted
	2. need collateral value
```solidity
function _healthFactor(address user) private view returns (uint256) {
	(uint256 totalDscMinted, uint256 collateralValueInUsd) = _getAccountInformation(user);
}
```

- `_getAccountInformation`
```solidity
function _getAccountInformation(address user)
	private
	view
	returns (uint256 totalDscMinted, uint256 collateralValueInUsd)
{
	totalDscMinted = s_DSCMinted[user];
	collateralValueInUsd = getAccountCollateralValue(user);
}
```

- `getAccountCollateralValue`
```solidity
function getAccountCollateralValue(address user) public view returns (uint256 totalCollateralValueInUsd) {
	for (uint256 i = 0; i < s_collateralTokens.length; i++) {
		address token = s_collateralTokens[i];
		uint256 amount = s_collateralDeposited[user][token];
		totalCollateralValueInUsd += getUsdValue(token, amount);
	}

	return totalCollateralValueInUsd;
}
```

- `getUsdValue`
```solidity
function getUsdValue(address token, uint256 amount) public view returns (uint256) {
	AggregatorV3Interface priceFeed = AggregatorV3Interface(s_priceFeeds[token]);
	(, int256 price,,,) = priceFeed.latestRoundData();

	return ((uint256(price) * ADDITIONAL_FEED_PRECISION) * amount) / PRECISION;
}
```

- `forge install smartcontractkit/chainlink-brownie-contracts@0.6.1 --no-git`
```
import {AggregatorV3Interface} from "@chainlink/contracts/src/v0.8/interfaces/Aggregatorv3Interface.sol";
```

#### Creating and retrieving the health factor
- we updated the `_healthfactor` function
```solidity
function _healthFactor(address user) private view returns (uint256) {
	(uint256 totalDscMinted, uint256 collateralValueInUsd) = _getAccountInformation(user);

	return (collateralValueInUsd/totalDscMinted);
}
```
- but we still need a liquidation threshold
```solidity
uint256 private constant LIQUIDATION_THRESHOLD = 50;
```

- updated `_healthfactor`
	- the health factor needs to be greater than 1
	- overcollateralized by at least 200%
```
function _healthFactor(address user) private view returns (uint256) {
	(uint256 totalDscMinted, uint256 collateralValueInUsd) = _getAccountInformation(user);

	uint256 collateralAdjustedForThreshold = (collateralValueInUsd * LIQUIDATION_THRESHOLD) / LIQUIDATION_PRECISION;

	return (collateralAdjustedForThreshold * PRECISION) / totalDscMinted;
}
```

- `_revertIfHealthFactorIsBroken`
```solidity
function _revertIfHealthFactorIsBroken(address user) internal view {
	uint256 userHealthFactor = _healthFactor(user);

	if (userHealthFactor < MIN_HEALTH_FACTOR) {
		revert DSCEngine__BreaksHealthFactor(userHealthFactor);
	}
}
```

#### Finishing the mint Function
```solidity
function mindDsc(uint256 amountDscToMint) external moreThanZero(amountDscToMint) nonReentrant {
	s_DSCMinted[msg.sender] += amountDscToMint;
	_revertIfHealthFactorIsBroken(msg.sender);
	
	bool minted = i_dsc.mint(msg.sender, amountDscToMint);
	if (!minted) {
		revert DSCEngine__MintFailed();
	}
}
```

#### Creating the deployment script
- [chainlink pricefeeds](https://docs.chain.link/data-feeds/price-feeds/addresses)
- initial deploy script:
```solidity
//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import {Script} from "forge-std/Script.sol";
import {DecentralizedStableCoin} from "../src/DecentralizedStableCoin.sol";
import {DSCEngine} from "../src/DSCEngine.sol";

contract DeployDSC is Script {
    function run() external returns (DecentralizedStableCoin, DSCEngine) {
        vm.startBroadcast();
        DecentralizedStableCoin dsc = new DecentralizedStableCoin();
        // DSCEngine engine = new DSCEngine(dsc);
        vm.stopBroadcast();
    }
}
```

- `DSCEngine engine = new DSCEngine(dsc);` takes more arguments than just `dsc`
```solidity
constructor(address[] memory tokenAddresses, address[] memory priceFeedAddresses, address dscAddress) {...}
```

- So we have to create a helper config for the other arguments
```solidity
//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import {Script} from "../forge-std/Script.sol";

contract HelperConfig is Script {

}
```

- We add a struct for the network config
```solidity
struct NetworkConfig {
	address wethUsdPriceFeed;
	address wbtcUsdPriceFeed;
	address weth;
	address wbtc;
	uint256 deployerKey;
}
```

- Add the `NetworkConfig`
```solidity
NetworkConfig public activeNetworkConfig;

constructor() {}

function getSepoliaEthConfig() public view returns(NetworkConfig memory ) {
	return NetworkConfig({
		wethUsdPriceFeed: 0x694AA1769357215DE4FAC081bf1f309aDC325306,
		wbtcUsdPriceFeed: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43,
		weth: 0xdd13E55209Fd76AfE204dBda4007C227904f0a81,
		wbtc: 0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063,
		deployerKey: vm.envUint("PRIVATE_KEY")
	});
}
```

- Add the `getOrCreateAnvilEthConfig` function which is going to require the Mock V3 aggregator... `MockV3Aggregator.sol`:
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title MockV3Aggregator
 * @notice Based on the FluxAggregator contract
 * @notice Use this contract when you need to test
 * other contract's ability to read data from an
 * aggregator contract, but how the aggregator got
 * its answer is unimportant
 */

contract MockV3Aggregator {
    uint256 public constant version = 0;
    uint8 public decimals;
    int256 public latestAnswer;
    uint256 public latestTimestamp;
    uint256 public latestRound;

    mapping(uint256 => int256) public getAnswer;
    mapping(uint256 => uint256) public getTimestamp;
    mapping(uint256 => uint256) private getStartedAt;

    constructor(uint8 _decimals, int256 _initialAnswer) {
        decimals = _decimals;
        updateAnswer(_initialAnswer);
    }

    function updateAnswer(int256 _answer) public {
        latestAnswer = _answer;
        latestTimestamp = block.timestamp;
        latestRound++;
        getAnswer[latestRound] = _answer;
        getTimestamp[latestRound] = block.timestamp;
        getStartedAt[latestRound] = block.timestamp;
    }

    function updateRoundData(uint80 _roundId, int256 _answer, uint256 _timestamp, uint256 _startedAt) public {
        latestRound = _roundId;
        latestAnswer = _answer;
        latestTimestamp = _timestamp;
        getAnswer[latestRound] = _answer;
        getTimestamp[latestRound] = _timestamp;
        getStartedAt[latestRound] = _startedAt;
    }

    function getRoundData(uint80 _roundId)
        external
        view
        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)
    {
        return (_roundId, getAnswer[_roundId], getStartedAt[_roundId], getTimestamp[_roundId], _roundId);
    }

    function latestRoundData()
        external
        view
        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)
    {
        return (
            uint80(latestRound),
            getAnswer[latestRound],
            getStartedAt[latestRound],
            getTimestamp[latestRound],
            uint80(latestRound)
        );
    }

    function description() external pure returns (string memory) {
        return "v0.6/tests/MockV3Aggregator.sol";
    }
}
```
- And import it
```solidity
import {MockV3Aggregator} from "../test/mocks/MockV3Aggregator.sol";
```


- We can import `ERC20Mock from openzeppelin`:
```solidity
import {ERC20Mock} from "@openzeppelin/contracts/mocks/token/ERC20Mock.sol";
```

- `getOrCreateAnvilEthConfig` function
```solidity
function getOrCreateAnvilEthConfig() public returns (NetworkConfig memory) {
	if (activeNetworkConfig.wbtcUsdPriceFeed != address(0)) {
		return activeNetworkConfig;
	}

	vm.startBroadcast();
	MockV3Aggregator ethUsdPriceFeed = new MockV3Aggregator(
		DECIMALS,
		ETH_USD_PRICE

	);
	ERC20Mock wethMock = new ERC20Mock("WETH", "WETH", msg.sender, 1000e8);

	MockV3Aggregator btcUsdPriceFeed = new MockV3Aggregator(
		DECIMALS,
		BTC_USD_PRICE
	);
	ERC20Mock wbtcMock = new ERC20Mock("WBTC", "WBTC", msg.sender, 1000e8);
	vm.stopBroadcast();

	return NetworkConfig({
		wethUsdPriceFeed: address(ethUsdPriceFeed),
		wbtcUsdPriceFeed: address(btcUsdPriceFeed),
		weth: address(wethMock),
		wbtc: address(wbtcMock),
		deployerKey: DEFAULT_ANVIL_KEY
	});
}
```

- update the constructor to use active network conditionally based on whether or not sepolia is being used:
```solidity
constructor() {
	if (block.chainid == 11155111) {
		activeNetworkConfig = getSepoliaEthConfig();
	} else {
		activeNetworkConfig = getOrCreateAnvilEthConfig();
	}
}
```

- we can complete the `DeployDSC.s.sol` script
```solidity
//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import {Script} from "forge-std/Script.sol";
import {DecentralizedStableCoin} from "../src/DecentralizedStableCoin.sol";
import {DSCEngine} from "../src/DSCEngine.sol";
import {HelperConfig} from "./HelperConfig.s.sol";

contract DeployDSC is Script {
    address[] public tokenAddresses;
    address[] public priceFeedAddresses;

    function run() external returns (DecentralizedStableCoin, DSCEngine) {
        HelperConfig config = new HelperConfig();

        (address wethUsdPriceFeed, address wbtcUsdPriceFeed, address weth, address wbtc, uint256 deployerKey) =
            config.activeNetworkConfig();

        tokenAddresses = [weth, wbtc];
        priceFeedAddresses = [wethUsdPriceFeed, wbtcUsdPriceFeed];

        vm.startBroadcast(deployerKey);
        DecentralizedStableCoin dsc = new DecentralizedStableCoin();
        DSCEngine engine = new DSCEngine(tokenAddresses, priceFeedAddresses, address(dsc));
        dsc.transferOwnership(address(engine));
        vm.stopBroadcast();

        return (dsc, engine);
    }
}
```

#### Test the DSCEngine smart contract
- Setup `DSCEngine.test.t.sol`:
```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import {Test} from "forge-std/Test.sol";
import {DeployDSC} from "../../script/DeployDSC.s.sol";
import {DecentralizedStableCoin} from "../../src/DecentralizedStableCoin.sol";
import {DSCEngine} from "../../src/DSCEngine.sol";

contract DSCEngineTest is Test {
    DeployDSC deployer;
    DecentralizedStableCoin dsc;
    DSCEngine dsce;
    HelperConfig config;
    address ethUsdPriceFeed;
    address weth;

    function setUp() public {
        deployer = new DeployDSC();
        (dsc, dsce, config) = deployer.run();
        (ethUsdPriceFeed,, weth,,) = config.activeNetworkConfig();
    }
}
```

- test `testGetUsdValue`
```solidity
function testGetUsdValue() public {
	uint256 ethAmount = 15e18;
	uint256 expectedUsd = 30000e18;
	uint256 actualUsd = dsce.getUsdValue(weth, ethAmount);
	assertEq(expectedUsd, actualUsd);
}
```
- `forge test --mt testGetUsdValue`
- this test will fail as is when running on sepolia because we're hard coding the value

- test `testRevertsIfCollateralZero`
```solidity
function testRevertsIfCollateralZero() public {
	vm.startPrank(USER);
	ERC20Mock(weth).approve(address(dsce), AMOUNT_COLLATERAL);

	vm.expectRevert(DSCEngine.DSCEngine__NeedsMoreThanZero.selector);
	dsce.depositCollateral(weth, 0);
	vm.stopPrank();
}
```
- `forge test --mt testRevertsIfCollateralZero`

- add sepolia rpc url to `.env` file and run `source .env` in order to run:
	- `forge test --fork-url $SEPOLIA_RPC_URL`

#### Create the `depostAndMint` function
- The purpose of this protocol is to deposit collateral and mint the stablecoin
- This function will call the deposit and mint functions combining them in one transaction
```solidity
/**
 * @param tokenCollateralAddress The address of the token to deposit as collateral
 * @param amountCollateral The amount of collateral to deposit
 * @param amountDscToMint The amount of stablecoin to mint
 * @notice This function will deposit your collateral and mint DSC in one transaction
 */

function depositCollateralAndMintDsc(
	address tokenCollateralAddress,
	uint256 amountCollateral,
	uint256 amountDscToMint
) external {
	depositCollateral(tokenCollateralAddress, amountCollateral);
	mintDsc(amountDscToMint);
}
```

#### Create the `redeemCollateral` function
- We have a way to get money in, and now this function will be a way for users to get their money out
- In order to redeem collateral:
	- Health factor must still be 1 AFTER collateral is pulled
- DRY: Don't repeat yourself
	- In it's current form, the function isn't modular, but we will refactor it
- In this case, we may have to violate the CEI pattern because we need to make sure health factor is still 1 after collateral is pulled
	- We could create a `_calculateHealthFactorAfter()` function, but that would be gas intensive
	- So it's usually okay to transfer the token and then revert if health factor is bad
```solidity
function redeemCollateral(address tokenCollateralAddress, uint256 amountCollateral)
	public
	moreThanZero(amountCollateral)
	nonReentrant
{
	s_collateralDeposited[msg.sender][tokenCollateralAddress] -= amountCollateral;
	emit CollateralRedeemed(msg.sender, tokenCollateralAddress, amountCollateral);

	bool success = IERC20(tokenCollateralAddress).transfer(msg.sender, amountCollateral);

	if (!success) {
		revert DSCEngine__TransferFailed();
	}

	_revertIfHealthFactorIsBroken(msg.sender);
}
```

- First, we need to burn the DSC, then redeem the ETH in order to avoid breaking the health factor... so we need to combine redeeming collateral with burning DSC
```solidity
function burnDsc(uint256 amount) public moreThanZero(amount) {
	s_DSCMinted[msg.sender] -= amount;
	
	bool success = i_dsc.transferFrom(msg.sender, address(this), amount);
	if (!success) {
		revert DSCEngine__TransferFailed();
	}

	i_dsc.burn(amount);
	_revertIfHealthFactorIsBroken(msg.sender);
}
```
- We should not have to check if health factor is damaged, because the burn function is removing debt which will increase the health factor

- Now we can combine the two functions into one transaction:
```solidity
function redeemCollateralForDsc(address tokenCollateralAddress, uint256 amountCollateral, uint256 amountDscToBurn)
	external
{
	burnDsc(amountDscToBurn);
	redeemCollateral(tokenCollateralAddress, amountCollateral);
	// redeem collateral alrady checks health factor so _revertIfHealthFactorIsBroken not needed
}
```

#### Setup Liquidations
- The `liquidate` function is the key that holds the system together... it allows for a way to remove undercollateralized positions
- If someone is almost under collateralized, users need to be incentivized to liquidate the position
	- Other users would pay off the loan and keep remaining collateral at a discount
- This system only works, if it is always overcollateralized... if it isn't then users don't have an incentive to liquidate
- Things we need to do
	- Check the healthfactor of the user
	- Burn the DSC debt and take collateral
	- Give a 10% bonus for liquidators

- We will need a function that can get the price in usd of the collateral
```solidity
function getTokenAmountFromUsd(address token, uint256 usdAmountInWei) public view returns (uint256) {
	AggregatorV3Interface priceFeed = AggregatorV3Interface(s_priceFeeds[token]);
	(, int256 price,,,) = priceFeed.latestRoundData();
	return (usdAmountInWei * PRECISION) / (uint256(price) * ADDITIONAL_FEED_PRECISION);
}
```

- The liquidate function so far:
```solidity
/**
 * @param collateral The ERC20 colleteral address to liquidate from the user
 * @param user The user being liquidated
 * @param debtToCover The amount of DSC to burn to improve health factor
 * @notice You can partially liquidate a user
 * @notice You will get a liquidation bonus for taking user's funds
 * @notice This function working assumes the protocol will be roughly 200% overcollateralized
 * @notice A known bug would be if the protocol was 100% or less collateralized
 * Bonus wouldn't be possible if undercollateralized, so a steep price decline without any liquidations could cause this issue
 */

function liquidate(address collateral, address user, uint256 debtToCover)
	external
	moreThanZero(debtToCover)
	nonReentrant
{
	uint256 startingUserHealthFactor = _healthFactor(user);
	if (startingUserHealthFactor >= MIN_HEALTH_FACTOR) {
		revert DSCEngine__HealthFactorOk();
	}

	uint256 tokenAmountFromDebtCovered = getTokenAmountFromUsd(collateral, debtToCover);

	// 10% bonus
	uint256 bonusCollateral = (tokenAmountFromDebtCovered * LIQUIDATION_BONUS) / LIQUIDATION_PRECISION;

	uint256 totalCollateralToRedeem = tokenAmountFromDebtCovered + bonusCollateral;
}
```
- From here, we need to: 
	- transfer the `totalCollateralToRedeem` to whoever is calling the liquidate function
	- burn the dsc from the user being liquidated

#### Refactor Liquidations
- Currently, our `redeemCollateral` function is hardcoded to use `msg.sender` to adjust collateral:
```solidity
s_collateralDeposited[msg.sender][tokenCollateralAddress] -= amountCollateral;
```
- This is incorrect as we need to update the collateral of the user being liquidated, not the user calling the function
- The first step to take to fix the mistake is to create an internal function:
```solidity
function _redeemCollateral(address from, address to, address tokenCollateralAddress, uint256 amountCollateral)
        private
    {
        s_collateralDeposited[from][tokenCollateralAddress] -= amountCollateral;
        emit CollateralRedeemed(from, to, tokenCollateralAddress, amountCollateral);

        bool success = IERC20(tokenCollateralAddress).transfer(to, amountCollateral);
        if (!success) {
            revert DSCEngine__TransferFailed();
        }
    }
```

- Then we can updated the redeem function
```solidity
function redeemCollateral(address tokenCollateralAddress, uint256 amountCollateral)
        public
        moreThanZero(amountCollateral)
        nonReentrant
    {
        _redeemCollateral(msg.sender, msg.sender, tokenCollateralAddress, amountCollateral);
        _revertIfHealthFactorIsBroken(msg.sender);
    }
```
- This function is called by the user, so `msg.sender` is used as the `from` and `to` address

- Then we update the liquidate function
```solidity
function liquidate(address collateral, address user, uint256 debtToCover)
        external
        moreThanZero(debtToCover)
        nonReentrant
    {
        uint256 startingUserHealthFactor = _healthFactor(user);
        if (startingUserHealthFactor >= MIN_HEALTH_FACTOR) {
            revert DSCEngine__HealthFactorOk();
        }

        uint256 tokenAmountFromDebtCovered = getTokenAmountFromUsd(collateral, debtToCover);
        uint256 bonusCollateral = (tokenAmountFromDebtCovered * LIQUIDATION_BONUS) / LIQUIDATION_PRECISION; // 10% bonus
        uint256 totalCollateralToRedeem = tokenAmountFromDebtCovered + bonusCollateral;

        _redeemCollateral(user, msg.sender, collateral, totalCollateralToRedeem);
    }
```
- Here the `to` and `from` parameters in the `_redeemCollateral` function are different

- We still need to account for the `burnDsc` function, and the first step is to create an internal burn function
```solidity
/**
 * @dev Low level internal function
 * do not call unless the function calling it is checking for health factors being broken
 */

function _burnDsc(address onBehalfOf, address dscFrom, uint256 amountDscToBurn) private {
	s_DSCMinted[onBehalfOf] -= amountDscToBurn;
	
	bool success = i_dsc.transferFrom(dscFrom, address(this), amountDscToBurn);
	if (!success) {
		revert DSCEngine__TransferFailed();

	}

	i_dsc.burn(amountDscToBurn);
}
```

- Then we can update the burn function using `msg.sender` for both address parameters
```solidity
function burnDsc(uint256 amount) public moreThanZero(amount) {
	_burnDsc(msg.sender, msg.sender, amount);
	_revertIfHealthFactorIsBroken(msg.sender);
}
```

- We can then add the `_burnDsc` function to `liquidate`
```solidity
function liquidate(address collateral, address user, uint256 debtToCover)
        external
        moreThanZero(debtToCover)
        nonReentrant
    {
        uint256 startingUserHealthFactor = _healthFactor(user);
        if (startingUserHealthFactor >= MIN_HEALTH_FACTOR) {
            revert DSCEngine__HealthFactorOk();
        }

        uint256 tokenAmountFromDebtCovered = getTokenAmountFromUsd(collateral, debtToCover);
        uint256 bonusCollateral = (tokenAmountFromDebtCovered * LIQUIDATION_BONUS) / LIQUIDATION_PRECISION; // 10% bonus
        uint256 totalCollateralToRedeem = tokenAmountFromDebtCovered + bonusCollateral;

        _redeemCollateral(user, msg.sender, collateral, totalCollateralToRedeem);
        _burnDsc(user, msg.sender, debtToCover);
    }
```

- We also need to check the health factor now
```solidity
function liquidate(address collateral, address user, uint256 debtToCover)
        external
        moreThanZero(debtToCover)
        nonReentrant
    {
	...
	uint256 endingUserHealthFactor = _healthFactor(user);
	if (endingUserHealthFactor <= startingUserHealthFactor) {
		revert DSCEngine__HealthFactorNotImproved();
	}
}
```

- We also need to make sure the health factor for the liquidator is ok
```solidity
function liquidate(address collateral, address user, uint256 debtToCover)
        external
        moreThanZero(debtToCover)
        nonReentrant
    {
	...
	_revertIfHealthFactorIsBroken(msg.sender);
}
```

- The value of our collateral always needs to be more than the minted DSC

#### `DSCEngine` advanced testing
- Formal verification: the act of proving or disproving a given property of a system using a mathematical model
- Symbolic execution is one technique used for formal verification
	- Explores different paths in a program creating a mathematical representation for each path

- Layer 1: unit test
	- The bare minimum, (testing individual functions???)
	- Tools: Foundry, Hardhat, Apeworks?, Truffle, Brownie
- Layer 2: fuzz test
	- Take random inputs and run them through your program
	- The NEW bare minimum
	- Define a property (invariant) and throw random data at the system in order to break the property
	- Tools: Foundry, Echidna, Consensys Dillegince Fuzzer
- Layer 3: static analysis
	- unit and fuzz testing are dynamic (we run or execute our code)
	- With static analysis, we just look at our code or have some tool look at our code
	- Tools: slither, solidity compiler
- Layer 4: formal verification
	- The act of proving or disproving a given property of the system
	- Fuzz testing tries to break you system by throwing random data at your system
	- Formal verification tries to break properties using mathematical proofs

- Many different ways to accomplish formal verfication, including:
	- Symbolic Execution
	- Abstract Interpretation
	- Model Checking

- Symbolic Execution
	- We try to explore the different paths of the program
	- For every execution path, we create a mathematical representation
	- So we create a mathematical formula for a certain function and we do this for our entire program and we push it into a "solver" that will return true or false
- There are many different types of solvers
	- SMT or SAT solver 
- SMT-LIB
	- A language made specifically to work with solvers
- Tools:
	- Manticore, HEVM, Solidity SMT Checker 
	- Gives us SMT output which we can run through a solver, but these tools already do that for us

- Steps
	1. We create solidity code and understand the invariants
	2. Covert our code to math using some symbolic execution tool
		- We create a set of boolean expressions that represent every execution path of our code
	3. Dump this Math into a solver (like z3???) to see if our property can be broken

- Solidity command:
```bash
solc --model-checker-engine chc --model-checker-targets overflow FileName.sol
```

- These are not a one size fits all approach
- Symbolic execution can run into the "path explosion problem"
	- There are too many paths for a computer to explore in a reasonable amount of time... a solver would not be able to finish
	- An infinite loop would require significant effort

- [secure contracts](https://secure-contracts.com)

- This isn't a guarantee that code is bug free... it just mathematically proves the code does the one specific thing you're testing correctly
- Key takeaway is to become proficient at stateful fuzzing

#### [Fuzz and Invariant Tests]( https://www.youtube.com/watch?v=juyY-CTolac)
- Invariant: Property of our system that should always hold

- Using foundry, this would be an example of a unit test:
```solidity
function testIAlwaysGetZero() public {
	uint256 data =  0;
	exampleContract.doStuff(data);
	assert(exampleContract.shouldAlwaysBeZero()==0);
}
```
- We are hard coding the data

- A fuzz test would look like this
```solidity
function testIAlwaysGetZeroFuzz() public {
	exampleContract.doStuff(data);
	assert(exampleContract.shouldAlwaysBeZero()==0);
}
```
- Foundry will automatically randomize data

- Steps we need to take
	1. Understand our invariants
	2. Write a fuzz test for the invariant

- Stateless Fuzzing: The state of the previous run is discarded for every new run
- Stateful Fuzzing: Fuzzing where the final state of your previous run is the starting state of your next run

- To write a stateful fuzz test in foundry, we use the `invariant_` keyword and it requires a bit of setup
- We need to import `StdInvatiant` from foundry and inherit it in our test contract
```solidity
function invariant_testAlwaysIsZero() public {
	assert(exampleContract.shouldAlwaysBeZero() == 0);
}
```

- In foundry:
	- Fuzz test = random data to one function
	- Invariant tests = random data and random function calls to many functions
	- Foundry Fuzzing = Stateless Fuzzing
	- Foundry Invariant = Stateful Fuzzing

- Invariant examples:
	- New tokens minted < inflation rate
	- Only possible to have 1 winner in a lottery
	- Only withdraw what they deposit

#### Write Fuzz Tests
- `forge coverage` to check test coverage
- Add a test for the constructor to test the revert
```solidity
address[] public tokenAddresses;
address[] public priceFeedAddresses;

function testRevertsIfTokenLengthDoesntMatchPriceFeed() public {
	tokenAddresses.push(weth);
	priceFeedAddresses.push(ethUsdPriceFeed);
	priceFeedAddresses.push(btcUsdPriceFeed);           
	 vm.expectRevert(DSCEngine.DSCEngine__TokenAddressesAndPriceFeedAddressesMustBeSameLength.selector);

	new DSCEngine(tokenAddresses, priceFeedAddresses, address(dsc));
}
```

- Add a test for the `getTokenAmountFromUsd` function:
```solidity
function testGetTokenAmountFromUsd() public {
	uint256 usdAmount = 100 ether;
	uint256 expectedWeth = 0.05 ether; // assuming $2000 eth
	uint256 actualWeth = dsce.getTokenAmountFromUsd(weth, usdAmount);
	assertEq(expectedWeth, actualWeth);
}
```

- Add a test for the `depositCollateral` function to make sure we can't use unapproved tokens as collateral
```solidity
function testRevertsIfUnapprovedCollateral() public {
	ERC20Mock ranToken = new ERC20Mock("RAN", "RAN", USER, AMOUNT_COLLATERAL);

	vm.startPrank(USER);
	vm.expectRevert(DSCEngine.DSCEngine__TokenNotAllowed.selector);
	dsce.depositCollateral(address(ranToken), AMOUNT_COLLATERAL);
	vm.stopPrank();
}
```

- We already have a private version, but we need an external version of `getAccountInformation`:
```solidity
function getAccountInformation(address user) external view returns (uint256 totalDscMinted, uint256 collateralValueInUsd) {
	(totalDscMinted, collateralValueInUsd) = _getAccountInformation(user);
}
```

- We can create a `depositCollateral` modifier for testing
```solidity
modifier  depositedCollateral() {
	vm.startPrank(USER);
	ERC20Mock(weth).approve(address(dsce), AMOUNT_COLLATERAL);
	dsce.depositCollateral(weth, AMOUNT_COLLATERAL);
	vm.stopPrank();
	_;
}
```

- Then apply it to the test:
```solidity
function testCanDepositCollateralAndGetAccountInfo() public depositedCollateral {
	(uint256 totalDscMinted, uint256 collateralValueInUsd) = dsce.getAccountInformation(USER);
	uint256 expectedTotalDscMinted = 0;
	uint256 expectedDepositAmount = dsce.getTokenAmountFromUsd(weth, collateralValueInUsd);

	assertEq(totalDscMinted, expectedTotalDscMinted);
	assertEq(AMOUNT_COLLATERAL, expectedDepositAmount);
}
```

#### Setting up Invariant Tests
- When working with a codebase, we should always ask:
	1. What are our invariants/properties?

- [Foundry: Fuzz Testing](https://book.getfoundry.sh/forge/fuzz-testing)
	- In foundry, fuzz testing is STATELESS fuzz testing
- [Foundry: Invariant Testing](https://book.getfoundry.sh/forge/invariant-testing)
	- In Foundry, invariant testing is STATEFUL fuzz testing

 - Open Testing:
	 - Calls all the functions on a contract to try to break an invariant
	 - Good for initial run of code

- Handler-Based Testing:
	- For more complex programs
	- Narrows down the random calls to increase the likelihood of catching actual errors

- First, we add to `foundry.toml` to setup [invariant testing](https://book.getfoundry.sh/reference/config/testing#invariant)
```toml
[invariant]
runs = 128
depth = 128
fail_on_revert = true
```
- setting `fail_on_revert` to false lets us run quick open tests

- We create two files for fuzz testing
	- `InvariantsTest.t.sol`
		- This file has the invariants/properties of our system that should always hold
	- `Handler.t.sol`
		- This file narrows down the way we call functions

- Invariants for this project:
	1.  Total supply of dsc should be less than the total value of collateral
	2. Getter/View functions should never revert (evergreen invariant)
	- There are more that can be added here, but this project just focuses on these two

- If were to do open testing then `OpenInvariantsTest.t.sol` would use `targetContract(address(dsce));` in the `setUp` function
```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import {Test} from "forge-std/Test.sol";
import {StdInvariant} from "forge-std/StdInvariant.sol";
import {DeployDSC} from "../../script/DeployDSC.s.sol";
import {DSCEngine} from "../../src/DSCEngine.sol";
import {DecentralizedStableCoin} from "../../src/DecentralizedStableCoin.sol";
import {HelperConfig} from "../../script/HelperConfig.s.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract OpenInvariantsTest is StdInvariant, Test {
    DeployDSC deployer;
    DSCEngine dsce;
    DecentralizedStableCoin dsc;
    HelperConfig config;
    address weth;
    address wbtc;

    function setUp() external {
        deployer = new DeployDSC();
        (dsc,dsce,config) = deployer.run();
        (,,weth,wbtc,) = config.activeNetworkConfig();
        targetContract(address(dsce));
    }

    function invariant_protocolMustHaveMoreValueThanTotalSupply() public view {
        // get the value of all the collateral in the protocol
        // compare it to all the debt (dsc)
        uint256 totalSupply = dsc.totalSupply();
        uint256 totalWethDeposited = IERC20(weth).balanceOf(address(dsce));
        uint256 totalWbtcDeposited = IERC20(wbtc).balanceOf(address(dsce));

        uint256 wethValue = dsce.getUsdValue(weth, totalWethDeposited);
        uint256 wbtcValue = dsce.getUsdValue(wbtc, totalWbtcDeposited);

        assert(wethValue + wbtcValue >= totalSupply);
    }
}
```
- With this test as is and without handlers, nothing meaningful is happening as it randomly calls functions

#### Create the `depositCollateral` handler
- For `InvariantTest.t.sol`, we will have to change `targetContract(address(dsce));` to instead target the handler that we will create
- We want to create a way to only call the `redeemCollateral` function only when there is collateral to redeem

- First we setup `Handler.t.sol`
```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import {Test} from "forge-std/Test.sol";
import {DSCEngine} from "../../src/DSCEngine.sol";
import {DecentralizedStableCoin} from "../../src/DecentralizedStableCoin.sol";

contract Handler is Test {
    DSCEngine dsce;
    DecentralizedStableCoin dsc;

    constructor(DSCEngine _dscEngine, DecentralizedStableCoin _dsc) {
        dsce = _dscEngine;
        dsc = _dsc;
    }
}
```
- Initially, we have the constructor that will set the addresses for the `DSCEngine` and the `DecentralizedStableCoin`

- We need to import the Handler to our `InvariantTest.t.sol` file:
```solidity
...
import {Handler} from "./Handler.t.sol";

contract InvariantsTest is StdInvariant, Test {
	...
	Handler handler;

	function setUp() external {
        deployer = new DeployDSC();
        (dsc, dsce, config) = deployer.run();
        (,, weth, wbtc,) = config.activeNetworkConfig();
        handler = new Handler(dsce,dsc);
        targetContract(address(handler));
    }
    ...
}
```

- Next we add the `depositCollateral` function which will deposit random collaterals that are valid collaterals
```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import {Test} from "forge-std/Test.sol";
import {DSCEngine} from "../../src/DSCEngine.sol";
import {DecentralizedStableCoin} from "../../src/DecentralizedStableCoin.sol";

contract Handler is Test {
    DSCEngine dsce;
    DecentralizedStableCoin dsc;

    constructor(DSCEngine _dscEngine, DecentralizedStableCoin _dsc) {
        dsce = _dscEngine;
        dsc = _dsc;
    }

    function despositCollateral(address collateral, uint256 amountCollateral) public {
        dsce.depositCollateral(collateral, amountCollateral);
    }
}
```
- In this state, the Handler will only call the `depositCollateral` function... but it's using any random address for the collateral since we have `address collateral` as one of the parameters

- We can fix this by first creating a helper function that will only let us choose valid collateral
```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

...
import {ERC20Mock} from "@openzeppelin/contracts/mocks/ERC20Mock.sol";

contract Handler is Test {
	...
    ERC20Mock weth;
    ERC20Mock wbtc;

    constructor(DSCEngine _dscEngine, DecentralizedStableCoin _dsc) {
		...
        address[] memory collateralTokens = dsce.getCollateralTokens();
        weth = ERC20Mock(collateralTokens[0]);
        wbtc = ERC20Mock(collateralTokens[1]);
    }
	...
	
    // helper functions
    function _getCollateralFromSeed(uint256 collateralSeed) private view returns (ERC20Mock) {
        if (collateralSeed % 2 == 0) {
            return weth;
        }
        return wbtc;
    }
}
```

- If we make our Handler too specific so we can roll with `fail_on_revert = true`, we run the risk of ignoring edge cases... so there is a trade off in trying to accomplish runs that do not revert
- We want to add a `depositCollateral` function
```solidity
function despositCollateral(uint256 collateralSeed, uint256 amountCollateral) public {
        ERC20Mock collateral = _getCollateralFromSeed(collateralSeed);
        dsce.depositCollateral(address(collateral), amountCollateral);
    }
```
- In this state, we will get many reverts as 0 will sometimes be used for `amountCollateral`
- We can use `bound` that comes with `StdUtils`
```solidity
function bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {
        result = _bound(x, min, max);
        console2_log_StdUtils("Bound result", vm.toString(result));
    }
```

```solidity
function despositCollateral(uint256 collateralSeed, uint256 amountCollateral) public {
        ERC20Mock collateral = _getCollateralFromSeed(collateralSeed);
        amountCollateral = bound(amountCollateral,1,MAX_DEPOSIT_SIZE);

        vm.startPrank(msg.sender);
        collateral.mint(msg.sender,amountCollateral);
        collateral.approve(address(dsce),amountCollateral);
        dsce.depositCollateral(address(collateral), amountCollateral);
        vm.stopPrank();
    }
```

#### Create the `redeemCollateral` handler
- We can also add the `redeemCollateral` function
```solidity
function redeemCollateral(uint256 collateralSeed, uint256 amountCollateral) public {
        ERC20Mock collateral = _getCollateralFromSeed(collateralSeed);
        uint256 maxCollateralToRedeem = dsce.getCollateralBalanceOfUser(address(collateral),msg.sender);
        amountCollateral = bound(amountCollateral,1,maxCollateralToRedeem);
        dsce.redeemCollateral(address(collateral),amountCollateral);
    }
```
- In this state, if `maxCollateralToRedeem` is zero, the test will fail

- We can use the [`assume`](https://book.getfoundry.sh/cheatcodes/assume) cheatcode
	- If the boolean expression evaluates to false, the fuzzer will discard the current fuzz inputs and start a new fuzz run.
- Or we can just return if the input is 0
```solidity
 function redeemCollateral(uint256 collateralSeed, uint256 amountCollateral) public {
        ERC20Mock collateral = _getCollateralFromSeed(collateralSeed);
        uint256 maxCollateralToRedeem = dsce.getCollateralBalanceOfUser(address(collateral), msg.sender);

        amountCollateral = bound(amountCollateral, 0, maxCollateralToRedeem);
        if (amountCollateral == 0) {
            return;
        }

        dsce.redeemCollateral(address(collateral), amountCollateral);
    }
```
- with `fail_on_revert = true`, this fuzz test would not catch a bug that would allow users to redeem more than that have

#### Create the `mintDsc` handler
- We set `fail_on_revert = false` initially when we run the test just to see the amount of successful runs... if we aim to start with true, we may overlook certain edge cases
- Some will have a `continueOnRevert` folder and a `failOnRevert` folder
	- `continueOnRevert` will contain quicker, looser tests
	- `failOnRevert` will focus on making every test pass with `fail_on_revert = true`

- `continueOnRevert` test:
```solidity
function mintDsc(uint256 amount) public {
	amount = bound(amount, 1, MAX_DEPOSIT_SIZE);
	vm.startPrank(msg.sender);
	dsce.mintDsc(amount);
	vm.stopPrank();
}
```

- `failOnRever` test:
```solidity
function mintDsc(uint256 amount) public {
	(uint256 totalDscMinted, uint256 collateralValueInUsd) = dsce.getAccountInformation(msg.sender);
	
	int256 maxDscToMint = int256(collateralValueInUsd) / 2 - int256(totalDscMinted);
	if (maxDscToMint < 0) {
		return;
	}

	amount = bound(amount, 0, uint256(maxDscToMint));
	if (amount == 0) {
		return;
	}

	vm.startPrank(msg.sender);
	dsce.mintDsc(amount);
	vm.stopPrank();
}
```
#### Debugging the fuzz tests handler
- Currently, our `totalSupply` is always 0 in all the tests that we run
- We can use [`ghost variables`](https://book.getfoundry.sh/forge/invariant-testing#handler-ghost-variables) to see if a certain function is actually being called

- debugging:
	- In our `Handler` we can add `uint256 public timesMintIsCalled;` and increment in the the `mintDsc` function
	- Then we can `console.log("Times mint called: ", handler.timesMintIsCalled());` in `InvariantsTest.t.sol`
	- We see that the variable isn't incrementing, so that means `mintDsc` isn't being called
	- The zero check seems to always return
- The bug is related to using `msg.sender`... this allows for random addresses to be used, we need to use the same address that mints
	- If we fix it, we need to be aware that we may be overlooking cases where someone without collateral is able to mint

- To fix:
	- we can create an array in `Handlers`: `address[] public usersWithCollateralDeposited;`
	- in the `depositCollateral` function, we can push an address `usersWithCollateralDeposited.push(msg.sender);`
	- in `redeemCollateral` we can use an address from that array to start the prank: `address sender = usersWithCollateralDeposited[addressSeed % usersWithCollateralDeposited.length];`
```solidity
function mintDsc(uint256 amount, uint256 addressSeed) public {
	if (usersWithCollateralDeposited.length == 0) {
		return;
	}
	address sender = usersWithCollateralDeposited[addressSeed % usersWithCollateralDeposited.length];

	(uint256 totalDscMinted, uint256 collateralValueInUsd) = dsce.getAccountInformation(sender);
	int256 maxDscToMint = int256(collateralValueInUsd) / 2 - int256(totalDscMinted);
	if (maxDscToMint < 0) {
		return;
	}

	amount = bound(amount, 0, uint256(maxDscToMint));
	if (amount == 0) {
		return;
	}

	vm.startPrank(sender);
	dsce.mintDsc(amount);
	vm.stopPrank();
	timesMintIsCalledPost++;
}
```

- We should also have "given invariant" function
```solidity
function invariant_gettersShouldNotRevert() public {
	// all getter functions
}
```

- `forge inspect DSCEngine methods`
```bash
{
  "burnDsc(uint256)": "f6876608",
  "calculateHealthFactor(uint256,uint256)": "01f72884",
  "depositCollateral(address,uint256)": "a5d5db0c",
  "depositCollateralAndMintDsc(address,uint256,uint256)": "e90db8a3",
  "getAccountCollateralValue(address)": "7d1a4450",
  "getAccountInformation(address)": "7be564fc",
  "getAdditionalFeedPrecision()": "8f63d667",
  "getCollateralBalanceOfUser(address,address)": "31e92b83",
  "getCollateralTokenPriceFeed(address)": "1c08adda",
  "getCollateralTokens()": "b58eb63f",
  "getDsc()": "deb8e018",
  "getHealthFactor(address)": "fe6bcd7c",
  "getLiquidationBonus()": "59aa9e72",
  "getLiquidationPrecision()": "6c8102c0",
  "getLiquidationThreshold()": "4ae9b8bc",
  "getMinHealthFactor()": "8c1ae6c8",
  "getPrecision()": "9670c0bc",
  "getTokenAmountFromUsd(address,uint256)": "afea2e48",
  "getUsdValue(address,uint256)": "c660d112",
  "liquidate(address,address,uint256)": "26c01303",
  "mintDsc(uint256)": "c9b7c327",
  "redeemCollateral(address,uint256)": "9acd81b3",
  "redeemCollateralForDsc(address,uint256,uint256)": "f419ea9c"
}
```

#### Create the price feed handler
- Handlers can allow us to handle our `DSCEngine` contract and any other contract... other contracts in our case would be:
	- Price feed contract
	- WETH token
	- WBTC token

- The `MockV3Aggregator` has a function that easily allows us to update an answer:
```solidity
function updateAnswer(int256 _answer) public {
	latestAnswer = _answer;
	latestTimestamp = block.timestamp;
	latestRound++;
	getAnswer[latestRound] = _answer;
	getTimestamp[latestRound] = block.timestamp;
	getStartedAt[latestRound] = block.timestamp;
}
```

- So we'll use the `MockV3Aggregator`:
```solidity
...
import {MockV3Aggregator} from "../mocks/MockV3Aggregator.sol";

contract Handler is Test {
	...
    MockV3Aggregator public ethUsdPriceFeed;
	...
    constructor(DSCEngine _dscEngine, DecentralizedStableCoin _dsc) {
        ethUsdPriceFeed = MockV3Aggregator(dsce.getCollateralTokenPriceFeed(address(weth)));

    }
	...
}
```

- And now we can create and `updateCollateral` function
```solidity
function updateCollateralPrice(uint96 newPrice) public {
	int256 newPriceInt = int256(uint256(newPrice));
	ethUsdPriceFeed.updateAnswer(newPriceInt);
}
```
- We see that tests fail, and this is because this function changes the price of eth to something much smaller than it is
	- This is actually a bug in our system as a price decrease within the same block would lead to this behavior
- We can either try to solve this problem, or state that this is a known bug

#### Manage your oracles connection
- In our `DSCEngine`, we're using an oracle
- We can create an `OracleLib.sol` file to make sure that prices aren't stale
- [chainlink price feed](https://docs.chain.link/data-feeds/price-feeds/addresses?network=ethereum&page=1)
	- `ETH/USD` on Sepolia has a deviation of 1% and it is updated every 3600 seconds
- We want to write checks to make sure the price is actually updating every 3600s
	- If not, we should pause our contract
- We are going to utilize `import {AggregatorV3Interface} from "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";`
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {AggregatorV3Interface} from "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";

/**
 * @title OracleLib
 * @author Robin Punnoose
 * @notice This library is used to check the ChainLink Oracle for stale data
 * If a price is stale, the function will revert and render the DSCEngine unusable
 * We want the DSCEngine to freeze if prices become stale
 */

library OracleLib {
    error OracleLib__StalePrice();

    uint256 private constant TIMEOUT = 3 hours;

    function staleCheckLatestRoundData(AggregatorV3Interface priceFeed)
        public
        view
        returns (uint80, int256, uint256, uint256, uint80)
    {
        (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound) =
            priceFeed.latestRoundData();

        uint256 secondsSince = block.timestamp - updatedAt;

        if (secondsSince > TIMEOUT) revert OracleLib__StalePrice();
        return (roundId, answer, startedAt, updatedAt, answeredInRound);
    }
}
```
- We can use this in our `DSCEngine` to check for stale prices

- To use the library in our `DSCEngine`, we import the file. Then:
```solidity
using OracleLib for AggregatorV3Interface;
```
- Where we were initially calling `priceFeed.latestRoundData();` we can now call `priceFeed.staleCheckLatestRoundData();`

#### Preparing your protocol for an audit
- [checklist](https://github.com/nascentxyz/simple-security-toolkit)
- There is a security section later in the course, for now, we have this checklist
	1. [Development Process](https://github.com/nascentxyz/simple-security-toolkit/blob/main/development-process.md)
	2. [Audit Readiness Checklist](https://github.com/nascentxyz/simple-security-toolkit/blob/main/audit-readiness-checklist.md)
	3. [Pre-Launch Security Checklist](https://github.com/nascentxyz/simple-security-toolkit/blob/main/pre-launch-security-checklist.md)
	4. **[Incident Response Plan Template](https://github.com/nascentxyz/simple-security-toolkit/blob/main/incident-response-plan-template.md)**

### [Lesson 13 Foundry Upgrades](https://www.youtube.com/watch?v=wUjYK5gwNZs&t=17220s)

#### Upgradable Smart Contracts Overview
- We should deploy upgradable smart contracts as little as possible
- It seems like a good idea in theory, but there are many issues when a protocol has centralized control over contracts in this way
- Technically, smart contracts are immutable
	- The immutability refers to the logic of the contract, the state of the contract can still change
- A disadvantage of smart contracts is a negative effect on decentrality
- There are three main ways to upgrade contracts
	- Parameterize
	- Social Migration
	- Proxy

**1. Not really an upgrade/ Parameterize**
- Can't add new logic
- Can't add new storage
- Basically, we have a setter function that changes some variable
- A simple but inflexible approach

**More recently, we as a community have more or less decided upgradable contracts are bad**
- One argument is that if devs know that their contract isn't upgradable, they take more care in creating a bug free contract

**2. Social Migration**
- Deploy a new contract not connected to the old contract and have users migrate to the new contract
- Pros:
	- Trues to blockchain values
	- Easiest to audit
- Cons:
	- Lot of work to convince users to move
	- Different address
- This method would involve transferring the old state to the new contract: [trail of bits](https://blog.trailofbits.com/2018/10/29/how-contract-migration-works/)

**3. Proxies**
- Truest form of programmatic upgrades (some argue social migration)
- Proxies use a lot of low level functionality, the main one being [`delegatecall`](https://solidity-by-example.org/delegatecall/)
	- The code in the target contract is executed in the context of the calling contract
	- `msg.sender` and `msg.value` don't change
- We use a proxy contract address to `delegatcall` to some other contract address
	- We can have one proxy contract that will have the same address forever
	- This proxy contract can point to the correct implementation contract that has the logic
- When we want to upgrade, we create a new implementation contract and point the proxy to that contract

**Proxy Terminology**
1. Implementation contract:
	- Has all the logic for the protocol. 
	- When upgrading, launch a new implementation contract
1. Proxy contract:
	- Points to the correct implementation contract
	- Routes function calls to the correct implementation contract
1. User:
	- Makes calls to proxy contract
2. Admin:
	- The user or group of users who upgrade to a new implementation contract

**Issues with Proxies**
1. Storage clashes
2. Function selector clashes
- When using `delegatecall`, we're using the logic of `Contract B` inside `Contract A`
	- If `Contract B` is changing some value, it changes the value of whatever is in the same storage location as itself in `Contract A`
	- We can only append new storage variables in new implementation contracts... we can't reorder or change old ones
- `delegatecall` uses a function selector to find a function
	- function selector: a 4 byte hash of a function name and function signature that define a function
	- It could be possible that a function in the implementation contract has the same function selector as an admin function in the proxy contract

**Transparent Proxy Pattern**
- Admins can't call implementation contract functions
- Admins are only allowed to call admin functions
- User's can only call functions in the implementation contract
- This is a way to avoid certain function selector clashes

**Universal Upgradable Proxies (UUPS)**
- All the logic of upgrading is in the implementation contract
- The solidity compiler will be able to find functions with the same selector
- Save gas by not having to check for admin

**Diamond Pattern**
- Allows for multiple implementation contracts
- If you have a very large contract that doesn't fit in the allotted size for a single contract, this pattern would help
- This allows for granular upgrades

#### Using Delegatecall
- [solidity by example: delegatecall](https://solidity-by-example.org/delegatecall/)
	- `delegatecall` is a low level function similar to `call`.
	- When contract `A` executes `delegatecall` to contract `B`, `B`'s code is executed
	- with contract `A`'s storage, `msg.sender` and `msg.value`.
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

// NOTE: Deploy this contract first
contract B {
    // NOTE: storage layout must be the same as contract A
    uint public num;
    address public sender;
    uint public value;

    function setVars(uint _num) public payable {
        num = _num;
        sender = msg.sender;
        value = msg.value;
    }
}

contract A {
    uint public num;
    address public sender;
    uint public value;

    function setVars(address _contract, uint _num) public payable {
        // A's storage is set, B is not modified.
        (bool success, bytes memory data) = _contract.delegatecall(
            abi.encodeWithSignature("setVars(uint256)", _num)
        );
    }
}
```
- `Contract A` has a `setVars` function just like `Contract B`, but the function for `Contract A` makes a `delegatecall` to `Contract B` for the same function. So `Contract A` is using the function from `Contract B` while utilizing its own state
- Storage location is important, the names of the variables are irrelevant
- `Contract A` will be modified based on the storage locations that correspond with `Contract B`
- In `Contract A`, if we were to change `uint public num;` to something like `bool public num;`, `Contract B` would still be able to manipulate the storage slot on `Contact A`
- If we were to change the order of variables in `Contract B` and leave `Contract A` the way it is, we would not be changing the variables we expect to change

#### Overview of the EIP-1967
- [EIP 1967 - Proxy storage slots](https://eips.ethereum.org/EIPS/eip-1967)
- The basic concept is that we use the same address for a contract but the underlying code changes
- OpenZeppelin has a minimialistic proxy contract that we can use to start working with `delegatecall`: `import "@openzeppelin/contracts/proxy/Proxy.sol";`
- This contract uses a lot of "assembly" code in the form of [`Yul`](https://docs.soliditylang.org/en/latest/yul.html)
	- `Yul` allows us to write low level code that is close to the evm opcodes
	- Ideally, we want to limit our use `Yul` because it makes it easier to "screw things up"
```solidity
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Proxy.sol)

pragma solidity ^0.8.20;

/**
 * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM
 * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to
 * be specified by overriding the virtual {_implementation} function.
 *
 * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a
 * different contract through the {_delegate} function.
 *
 * The success and return data of the delegated call will be returned back to the caller of the proxy.
 */
abstract contract Proxy {
    /**
     * @dev Delegates the current call to `implementation`.
     *
     * This function does not return to its internal call site, it will return directly to the external caller.
     */
    function _delegate(address implementation) internal virtual {
        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize())

            // Call the implementation.
            // out and outsize are 0 because we don't know the size yet.
            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)

            // Copy the returned data.
            returndatacopy(0, 0, returndatasize())

            switch result
            // delegatecall returns 0 on error.
            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
        }
    }

    /**
     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback
     * function and {_fallback} should delegate.
     */
    function _implementation() internal view virtual returns (address);

    /**
     * @dev Delegates the current call to the address returned by `_implementation()`.
     *
     * This function does not return to its internal call site, it will return directly to the external caller.
     */
    function _fallback() internal virtual {
        _delegate(_implementation());
    }

    /**
     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other
     * function in the contract matches the call data.
     */
    fallback() external payable virtual {
        _fallback();
    }
}
```
- This contract utilizes `fallback` which points to the `_delegate` function
- Any time a proxy contract receive data for a function it doesn't recognize, it sends it over to some implementation contract where it will call it with `delegatecall`


- Our `SmallProxy` contract
```solidity
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.19;

import "@openzeppelin/contracts/proxy/Proxy.sol";

contract SmallProxy is Proxy {
    // This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1
    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

    function setImplementation(address newImplementation) public {
        assembly {
            sstore(_IMPLEMENTATION_SLOT, newImplementation)
        }
    }

    function _implementation() internal view override returns (address implementationAddress) {
        assembly {
            implementationAddress := sload(_IMPLEMENTATION_SLOT)
        }
    }
}
```
- `setImplementation` will change the address to the new implementation contract
- `_implementation` will return the address of the implementation contract
- To work with proxies, we don't really want to have anything in storage... but we do have to store the address of the implementation contract
	- EIP-1967 standardizes where proxies store the logic contract they delegate to

```solidity
contract ImplementationA {
    uint256 public value;

    function setValue(uint256 newValue) public {
        value = newValue;
    }
}

contract ImplementationB {
    uint256 public value;

    function setValue(uint256 newValue) public {
        value = newValue + 2;
    }
}
```
- Two different implementation contracts that can be used with the Proxy contract
- The Proxy contract will make `delegatecall` to the implementation contracts


```solidity
// helper function

function getDataToTransact(uint256 numberToUpdate) public pure returns (bytes memory) {
	return abi.encodeWithSignature("setValue(uint256)", numberToUpdate);
}

function readStorage() public view returns (uint256 valueAtStorageSlotZero) {
	assembly {
		valueAtStorageSlotZero := sload(0)
	}
}
```
- `getDataToTransact()` gets use the raw bytes of what we need to use  to call the `setValue()` function
- `readStorage()` is a way to read our storage in the `SmallProxy` contract

- The big picture of how this will work is that our `SmallProxy` contract will end up using the `fallback()` function since the function signature won't be found in the `SmallProxy` contract
- The `fallback()` will end up making a `delegatecall` to the implementation contract
- Using proxies, the developers can change the code at any point... so it's important to know who has the keys

- Function selector clashing is something to keep in mind. If we have functions that share same names in the `Proxy` and the `Implementation`, the function will never be called on the `Implementation` 

#### Universal Upgradable Smart Contract
- [UUPS vs Transparent](https://docs.openzeppelin.com/contracts/4.x/api/proxy#transparent-vs-uups)
	- [Transparent](https://blog.openzeppelin.com/the-transparent-proxy-pattern)
	- [EIP-1822 UUPS](https://eips.ethereum.org/EIPS/eip-1822)
- In UUPS proxies the upgrade is handled by the implementation and can eventually be removed
- [OpenZeppelin upgradeable](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable)
- `abstract` contracts have some function defined and some functions undefined
	- They expect their child classes to implement those functions
- For example `function _authorizeUpgrade(address newImplementation) internal virtual;`, the parent contract expects the child to define that function

```toml
remapping = [
    "@openzeppelin/contracts-upgradeable=lib/openzeppelin-contracts-upgradeable/contracts",
]
```
- ``forge remappings > remappings.txt``
- `import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";`

```solidity
// SPDX-License-Identifier: SEE LICENSE IN LICENSE
pragma solidity ^0.8.4;

import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";

contract BoxV1 is UUPSUpgradeable {
    uint256 internal number;

    function getNumber() external view returns (uint256) {
        return number;
    }

    function version() external pure returns (uint256) {
        return 1;
    }

    function _authorizeUpgrade(address newImplementation) internal override {}
}
```

- [storage gaps](https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#storage-gaps)
	- Proxies point to storage slots, not variable names. So the ordering of variable names matters. The old UUPS repo had `uint256[50] private _gap`
	- The private gap above saves 50 storage slots for adding new variables in the future
	- This would help collision of storage for different variables when upgrading

- [OpenZeppelin Initializable](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/58fa0f81c4036f1a3b616fdffad2fd27e5d5ce21/contracts/proxy/utils/Initializable.sol)
	- This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployedcbehind a proxy. 
	- Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an external initializer function, usually called `initialize`. 
	- It then becomes necessary to protect this initializer function so it can only be called once. 
	- The {initializer} modifier provided by this contract will have this effect.

 * An uninitialized contract can be taken over by an attacker. 
	 * This applies to both a proxy and its implementation contract, which may impact the proxy. 
	 * To prevent the implementation contract from being used, you should invoke the `{_disableInitializers}` function in the constructor to automatically lock it when it is deployed:
```solidity
/// @custom:oz-upgrades-unsafe-allow constructor
constructor() {
	_disableInitializers();
}
```

```solidity
// SPDX-License-Identifier: SEE LICENSE IN LICENSE
pragma solidity ^0.8.4;

import {OwnableUpgradeable} from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

contract BoxV1 is  Initializable, UUPSUpgradeable, OwnableUpgradeable {
    uint256 internal number;

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    function initialize() public initializer{
        __Ownable_init(msg.sender);
        __UUPSUpgradeable_init();
    }

    function getNumber() external view returns (uint256) {
        return number;
    }

    function version() external pure returns (uint256) {
        return 1;
    }

    function _authorizeUpgrade(address newImplementation) internal override {}
}
```
- A Proxy contract won't have a constructor
	- The proxy contact utilizes its own storage and "borrows" functions from the implementation contract
	- The initializer serves as a constructor

#### Deploy upgradeable smart contracts
- We create two files `DeployBox.s.sol` and `UpgradeBox.s.sol`
- [OZ ERC1967 Proxy](https://docs.openzeppelin.com/contracts/4.x/api/proxy)
	- We use the openzeppelin proxy to point to our implementation
```
forge install OpenZeppelin/openzeppelin-contracts --no-git
```

```solidity
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Proxy.sol)

pragma solidity ^0.8.20;

import {Proxy} from "../Proxy.sol";
import {ERC1967Utils} from "./ERC1967Utils.sol";

/**
 * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an
 * implementation address that can be changed. This address is stored in storage in the location specified by
 * https://eips.ethereum.org/EIPS/eip-1967[ERC-1967], so that it doesn't conflict with the storage layout of the
 * implementation behind the proxy.
 */

contract ERC1967Proxy is Proxy {
    /**
     * @dev Initializes the upgradeable proxy with an initial implementation specified by `implementation`.
     *
     * If `_data` is nonempty, it's used as data in a delegate call to `implementation`. This will typically be an
     * encoded function call, and allows initializing the storage of the proxy like a Solidity constructor.
     *
     * Requirements:
     *
     * - If `data` is empty, `msg.value` must be zero.
     */

    constructor(address implementation, bytes memory _data) payable {
        ERC1967Utils.upgradeToAndCall(implementation, _data);
    }

    /**
     * @dev Returns the current implementation address.
     *
     * TIP: To get this value clients can read directly from the storage slot shown below (specified by ERC-1967) using
     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.
     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`
     */

    function _implementation() internal view virtual override returns (address) {
        return ERC1967Utils.getImplementation();
    }
}
```
- This constructor takes two arguments, so we will have to call two arguments when instantiating in our contract

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import {Script} from "forge-std/Script.sol";
import {BoxV1} from "../src/BoxV1.sol";
import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";

contract DeployBox is Script {
    function run() external returns (address) {
        address proxy = deployBox();
        return proxy;
    }

    function deployBox() public returns (address) {
        BoxV1 box = new BoxV1(); // implementation logic
        ERC1967Proxy proxy = new ERC1967Proxy(address(box), "");
        return address(proxy);
    }
}
```

#### Upgrade UUPS proxy smart contracts
```
forge install chainaccelorg/foundry-devops --no-commit
```

- `upgradeTo` used in tutorial is deprecated, had to use 
```
function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {
	_authorizeUpgrade(newImplementation);
	_upgradeToAndCallUUPS(newImplementation, data);
}
```
- used `""` for second argument

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import {Script} from "forge-std/Script.sol";
import {DevOpsTools} from "lib/foundry-devops/src/DevOpsTools.sol";
import {BoxV2} from "../src/BoxV2.sol";
import {BoxV1} from "../src/BoxV1.sol";

contract UpgradeBox is Script {
    function run() external returns (address) {
        address mostRecentlyDeployed = DevOpsTools.get_most_recent_deployment("ERC1967proxy", block.chainid);
        vm.startBroadcast();
        BoxV2 newBox = new BoxV2();
        vm.stopBroadcast();
        address proxy = upgradeBox(mostRecentlyDeployed, address(newBox));
        return proxy;
    }

    function upgradeBox(address proxyAddress, address newBox) public returns (address) {
        vm.startBroadcast();
        BoxV1 proxy = BoxV1(proxyAddress);
        proxy.upgradeToAndCall(address(newBox), "");
        vm.startBroadcast();
        return address(proxy);
    }
}
```
- We point `BoxV1` to `BoxV2` as we gave `BoxV1` the `UUPSUpgradeable` library

#### Testing UUPS proxies
- We setup for testing
```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import {Test} from "forge-std/Test.sol";
import {DeployBox} from "../script/DeployBox.s.sol";
import {UpgradeBox} from "../script/UpgradeBox.s.sol";
import {BoxV1} from "../src/BoxV1.sol";
import {BoxV2} from "../src/BoxV2.sol";

contract DeployAndUpgradeTest is Test {
    DeployBox public deployer;
    UpgradeBox public upgrader;
    address public OWNER = makeAddr("owner");

    address public proxy;

    function setUp() public {
        deployer = new DeployBox();
        upgrader = new UpgradeBox();
        proxy = deployer.run();
    }
}
```

- We run a test to make sure we can't yet interact with contract 2
```solidity
 function testProxyStartsAsBox1() public {
	vm.expectRevert();
	BoxV2(proxy).setNumber(3);
}
```

- We upgrade the contract
```solidity
function testUpgrades() public {
	BoxV2 box2 = new BoxV2();
	
	upgrader.upgradeBox(proxy, address(box2));
	
	uint256 expectedValue = 2;
	assertEq(expectedValue, BoxV2(proxy).version());

	BoxV2(proxy).setNumber(7);
	assertEq(7, BoxV2(proxy).getNumber());
}
```
- We check the version, it should change from 1 to 2
- Then we check if we can set the number on the `BoxV2` contract

#### Deploying the stablecoin on the testnet
- An upgradeable smart contract is a centralization vector... a group can change the logic of the code

```make
-include .env

.PHONY: all test clean deploy fund help install snapshot format anvil scopefile

DEFAULT_ANVIL_KEY := 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80

all: remove install build

# Clean the repo
clean  :; forge clean

# Remove modules
remove :; rm -rf .gitmodules && rm -rf .git/modules/* && rm -rf lib && touch .gitmodules && git add . && git commit -m "modules"

install :; forge install foundry-rs/forge-std --no-commit && forge install openzeppelin/openzeppelin-contracts@v4.8.3 --no-commit && forge install openzeppelin/openzeppelin-contracts-upgradeable@v4.8.3 --no-commit && forge install cyfrin/foundry-devops@0.0.11 --no-commit 

# Update Dependencies
update:; forge update

build:; forge build

test :; forge test 

snapshot :; forge snapshot

format :; forge fmt

anvil :; anvil -m 'test test test test test test test test test test test junk' --steps-tracing --block-time 1

NETWORK_ARGS := --rpc-url http://localhost:8545 --private-key $(DEFAULT_ANVIL_KEY) --broadcast

ifeq ($(findstring --network sepolia,$(ARGS)),--network sepolia)
	NETWORK_ARGS := --rpc-url $(SEPOLIA_RPC_URL) --private-key $(PRIVATE_KEY) --broadcast --verify --etherscan-api-key $(ETHERSCAN_API_KEY) -vvvvv
endif

deploy:
	@forge script script/DeployBox.s.sol:DeployBox $(NETWORK_ARGS)

upgrade:
	@forge script script/UpgradeBox.s.sol:UpgradeBox $(NETWORK_ARGS)
```
- `make deploy ARGS="--network sepolia"`
- `make upgrade ARGS="--network sepolia"`
	- in `foundry.toml`, may have to set `ffi = true` (allow tests to call external scripts)
	- in the `run-latest.json`, may have to add `ERC1967Proxy` to `contractName` field if it is null
- `cast call <Contract Address> "functionName()" --rpc-url $SEPOLIA_RPC_URL` (call to a contract) 
- `cast send <Contract Address> "functionName(type)" argument --rpc-url $SEPOLIA_RPC_URL` (send message to contract)
- `cast --to-base <hex number> dec` (convert to decimal)

### [Lesson 14 Foundry Upgrades](https://www.youtube.com/watch?v=wUjYK5gwNZs&t=21945s)
#### Introduction to DAOs
- [Plutocracy is bad](https://vitalik.eth.limo/general/2018/03/28/plutocracy.html)
- [DAOs are not corporations](https://vitalik.eth.limo/general/2022/09/20/daos.html)

- Decentralized Autonomous Organization
	- Any group that is governed by a transparent set of rules found on a blockchain or a smart contract
	- DeGov: A company/organization operated exclusively through code

- [Compound governance](https://compound.finance/governance)

- Usual process
	 - A proposal is created in a `propose` transaction
	 - After a short delay, a proposal becomes active (can be voted on)
	 - If it passes, it reaches succeeded
	 - If a vote passes, it enters the queued stage (a wait period before proposal goes into effect)
	 - Finally, the proposal is executed
	- [Snapshot](https://snapshot.org/#/)
	- An offchain app that can be used to create proposals to gather sentiment

**Voting Mechanism**
A DAO needs a way for participants to engage
- Token Based Voting
	- An easy approach is to use an erc20 token or an nft as voting power
	- Runs into the issue of people that can purchase the most have the bigger vote
- Skin in the game
	- This system penalizes users for votes with bad outcomes
	- Who decides what on an outcome being bad?
- Proof of personhood or participation
	- One vote per user regardless of amount owned
	- The issue is sybil resistance... a user can create multiple accounts

**Voting Implementation**
- On chain
	- Smart contract... a user calls a function on the contract
	- This costs gas...
	- [Governer C](https://github.com/D3LAB-DAO/Governor-C/blob/main/contracts/example/Funding.sol)
- Off chain
	- Off chain voting can still be decentralized
	- The idea is to sign a transaction off chain as a means to vote which would circumvent the gas fees... the transactions is sent to a decentralized database... which is tallied and sent to the blockchain (using an oracle)
	- Alternatively, all signed transactions can be replayed in a single transaction to the blockchain in order to save gas

**No code solutions**
- [DaoStack](https://www.alchemy.com/dapps/daostack)
- [Aragon](https://aragon.org/)
- [Colony](https://colony.io/)
- [DAOHaus](https://daohaus.club/)
If you don't want to pay any fees and you want more granular control, it may be a better idea to build from scratch

**Coding/Other solutions**
- [OpenZeppeling](https://docs.openzeppelin.com/contracts/4.x/governance)
- [Snapshot](https://snapshot.org/#/): get a sentiment of a dao and perform the execution
- [Zodiac](https://zodiac.wiki/index.php?title=Introduction:_Zodiac_Standard) : a suite of dao based tools
- [tally](https://www.tally.xyz/): a ui that allows users to see and interact with smart contracts
- [gnosis safe multisig wallet](https://safe.global/wallet): most daos are going to start with some type of centrality where voting happens through a few key members

**Legality**
- The state of wyoming legally recognized daos

#### Project Setup
We will be building a plutocracy dao based on ERC20 tokens, however, this type of governance can run into issues in the future due to speculators/investing.

**Project summary**
1. We are going to have a contract controlled by a DAO
2. Every transaction that the DAO wants to send has to be voted on
3. We will use ERC20 tokens for voting (bad model, research better models)

**Project start**
```
forge init --no-git
```

```
forge install openzeppelin/openzeppelin-contracts --no-git
```

`foundry.toml`
```
[profile.default]
src = "src"
out = "out"
libs = ["lib"]
remappings = ["@openzeppelin/contracts=lib/openzeppelin-contracts/contracts/"]
```
- `forge remappings > remappings.txt`

`Box.sol`
```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

contract Box is Ownable {
    uint256 private s_number;

    event NumberChanged(uint256 number);

    constructor() Ownable(msg.sender) {}

    function store(uint256 newNumber) public onlyOwner {
        s_number = newNumber;
        emit NumberChanged(newNumber);
    }

    function getNumber() external view returns (uint256) {
        return s_number;
    }
}
```

#### Governance Token
We could implement this from scratch, but instead, we can use OpenZeppelin
- [OpenZeppelin Wizard](https://docs.openzeppelin.com/contracts/5.x/wizard)
```solidity
// SPDX-License-Identifier: MIT
// Compatible with OpenZeppelin Contracts ^5.0.0
pragma solidity ^0.8.20;

import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {ERC20Permit} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol";
import {ERC20Votes} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol";
import {Nonces} from "@openzeppelin/contracts/utils/Nonces.sol";

contract MyToken is ERC20, ERC20Permit, ERC20Votes {
    constructor() ERC20("MyToken", "MTK") ERC20Permit("MyToken") {}

    // The following functions are overrides required by Solidity.
    function _update(address from, address to, uint256 value)
        internal
        override(ERC20, ERC20Votes)
    {
        super._update(from, to, value);
    }

    function nonces(address owner)
        public
        view
        override(ERC20Permit, Nonces)
        returns (uint256)
    {
        return super.nonces(owner);
    }
}
```
- `ERC20Permit`: Implementation of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].
- `ERC20Votes`: Extension of ERC-20 to support Compound-like voting and delegation. This version is more generic than Compound's, and supports token supply up to 2^208^ - 1, while COMP is limited to 2^96^ - 1.
	- This extension keeps a history (checkpoints) of each account's vote power.
	- Vote power can be delegated either by calling the {delegate} function directly, or by providing a signature to be used with `{delegateBySig}`

```solidity
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Votes.sol)

pragma solidity ^0.8.20;

import {ERC20} from "../ERC20.sol";
import {Votes} from "../../../governance/utils/Votes.sol";
import {Checkpoints} from "../../../utils/structs/Checkpoints.sol";

/**
 * @dev Extension of ERC-20 to support Compound-like voting and delegation. This version is more generic than Compound's,
 * and supports token supply up to 2^208^ - 1, while COMP is limited to 2^96^ - 1.
 *
 * NOTE: This contract does not provide interface compatibility with Compound's COMP token.
 *
 * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either
 * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting
 * power can be queried through the public accessors {getVotes} and {getPastVotes}.
 *
 * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it
 * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.
 */

abstract contract ERC20Votes is ERC20, Votes {
    /**
     * @dev Total supply cap has been exceeded, introducing a risk of votes overflowing.
     */

	error ERC20ExceededSafeSupply(uint256 increasedSupply, uint256 cap);

    /**
     * @dev Maximum token supply. Defaults to `type(uint208).max` (2^208^ - 1).
     *
     * This maximum is enforced in {_update}. It limits the total supply of the token, which is otherwise a uint256,
     * so that checkpoints can be stored in the Trace208 structure used by {{Votes}}. Increasing this value will not
     * remove the underlying limitation, and will cause {_update} to fail because of a math overflow in
     * {_transferVotingUnits}. An override could be used to further restrict the total supply (to a lower value) if
     * additional logic requires it. When resolving override conflicts on this function, the minimum should be
     * returned.
     */
    function _maxSupply() internal view virtual returns (uint256) {
        return type(uint208).max;
    }

    /**
     * @dev Move voting power when tokens are transferred.
     *
     * Emits a {IVotes-DelegateVotesChanged} event.
     */
    function _update(address from, address to, uint256 value) internal virtual override {
        super._update(from, to, value);
        if (from == address(0)) {
            uint256 supply = totalSupply();
            uint256 cap = _maxSupply();
            if (supply > cap) {
                revert ERC20ExceededSafeSupply(supply, cap);
            }
        }
        _transferVotingUnits(from, to, value);
    }

    /**
     * @dev Returns the voting units of an `account`.
     *
     * WARNING: Overriding this function may compromise the internal vote accounting.
     * `ERC20Votes` assumes tokens map to voting units 1:1 and this is not easy to change.
     */
    function _getVotingUnits(address account) internal view virtual override returns (uint256) {
        return balanceOf(account);
    }

    /**
     * @dev Get number of checkpoints for `account`.
     */
    function numCheckpoints(address account) public view virtual returns (uint32) {
        return _numCheckpoints(account);
    }

    /**
     * @dev Get the `pos`-th checkpoint for `account`.
     */
    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoints.Checkpoint208 memory) {
        return _checkpoints(account, pos);
    }
}
```

#### Creating the governor contract
We can again use the [OpenZeppelin Wizard](https://docs.openzeppelin.com/contracts/5.x/wizard) to create the governor contract.
- Allows us to set a 'voting delay' which allows for a period before voting starts
- Set a 'voting period' for how long the voting will last
- Set a 'proposal threshold' to set the minimum amount of votes needed to create a proposal
- Set a 'quorum' for a minimum amount of votes needed to pass the proposal

```solidity
// SPDX-License-Identifier: MIT
// Compatible with OpenZeppelin Contracts ^5.0.0
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/governance/Governor.sol";
import "@openzeppelin/contracts/governance/extensions/GovernorSettings.sol";
import "@openzeppelin/contracts/governance/extensions/GovernorCountingSimple.sol";
import "@openzeppelin/contracts/governance/extensions/GovernorVotes.sol";
import "@openzeppelin/contracts/governance/extensions/GovernorVotesQuorumFraction.sol";
import "@openzeppelin/contracts/governance/extensions/GovernorTimelockControl.sol";

contract MyGovernor is Governor, GovernorSettings, GovernorCountingSimple, GovernorVotes, GovernorVotesQuorumFraction, GovernorTimelockControl {
    constructor(IVotes _token, TimelockController _timelock)
        Governor("MyGovernor")
        GovernorSettings(7200 /* 1 day */, 50400 /* 1 week */, 0)
        GovernorVotes(_token)
        GovernorVotesQuorumFraction(4)
        GovernorTimelockControl(_timelock)
    {}

    // The following functions are overrides required by Solidity.
    function votingDelay()
        public
        view
        override(Governor, GovernorSettings)
        returns (uint256)
    {
        return super.votingDelay();
    }

    function votingPeriod()
        public
        view
        override(Governor, GovernorSettings)
        returns (uint256)
    {
        return super.votingPeriod();
    }

    function quorum(uint256 blockNumber)
        public
        view
        override(Governor, GovernorVotesQuorumFraction)
        returns (uint256)
    {
        return super.quorum(blockNumber);
    }

    function state(uint256 proposalId)
        public
        view
        override(Governor, GovernorTimelockControl)
        returns (ProposalState)
    {
        return super.state(proposalId);
    }

    function proposalNeedsQueuing(uint256 proposalId)
        public
        view
        override(Governor, GovernorTimelockControl)
        returns (bool)
    {
        return super.proposalNeedsQueuing(proposalId);
    }

    function proposalThreshold()
        public
        view
        override(Governor, GovernorSettings)
        returns (uint256)
    {
        return super.proposalThreshold();
    }

    function _queueOperations(uint256 proposalId, address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash)
        internal
        override(Governor, GovernorTimelockControl)
        returns (uint48)
    {
        return super._queueOperations(proposalId, targets, values, calldatas, descriptionHash);
    }

    function _executeOperations(uint256 proposalId, address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash)
        internal
        override(Governor, GovernorTimelockControl)
    {
        super._executeOperations(proposalId, targets, values, calldatas, descriptionHash);
    }

    function _cancel(address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash)
        internal
        override(Governor, GovernorTimelockControl)
        returns (uint256)
    {
        return super._cancel(targets, values, calldatas, descriptionHash);
    }

    function _executor()
        internal
        view
        override(Governor, GovernorTimelockControl)
        returns (address)
    {
        return super._executor();
    }
}
```

**`Governor.sol`**: 
- Core of the governance system, designed to be extended through various modules.
- keeps a mapping of proposals: 
```solidity
struct ProposalCore {
	address proposer;
	uint48 voteStart;
	uint32 voteDuration;
	bool executed;
	bool canceled;
	uint48 etaSeconds;
}

mapping(uint256 proposalId => ProposalCore) private _proposals;
```
- `propose` is one of the main functions
```solidity
/**
 * @dev See {IGovernor-propose}. This function has opt-in frontrunning protection, described in {_isValidDescriptionForProposer}.
 */
function propose(
	address[] memory targets,
	uint256[] memory values,
	bytes[] memory calldatas,
	string memory description
) public virtual returns (uint256) {
	address proposer = _msgSender();

	// check description restriction
	if (!_isValidDescriptionForProposer(proposer, description)) {
		revert GovernorRestrictedProposer(proposer);
	}
	
	// check proposal threshold
	uint256 votesThreshold = proposalThreshold();
	if (votesThreshold > 0) {
		uint256 proposerVotes = getVotes(proposer, clock() - 1);
		if (proposerVotes < votesThreshold) {
			revert GovernorInsufficientProposerVotes(proposer, proposerVotes, votesThreshold);
		}
	}

	return _propose(targets, values, calldatas, description, proposer);
}
```
- `castVote` is another important function
```solidity
/**
* @dev See {IGovernor-castVote}.
*/
function castVote(uint256 proposalId, uint8 support) public virtual returns (uint256) {
	address voter = _msgSender();
	return _castVote(proposalId, voter, support, "");
}
```

**`GovernerSettings.sol`**: 
- Extension of {Governor} for settings updatable through governance.
- adds some key features
```solidity
// amount of token
uint256 private _proposalThreshold;
// timepoint: limited to uint48 in core (same as clock() type)
uint48 private _votingDelay;
// duration: limited to uint32 in core
uint32 private _votingPeriod;
```

**`GovernorCountingSimple`**: 
- Extension of {Governor} for simple, 3 options, vote counting.
```solidity
/**
 * @dev Supported vote types. Matches Governor Bravo ordering.
 */

enum VoteType {
	Against,
	For,
	Abstain
}

struct ProposalVote {
	uint256 againstVotes;
	uint256 forVotes;
	uint256 abstainVotes;
	mapping(address voter => bool) hasVoted;
}

mapping(uint256 proposalId => ProposalVote) private _proposalVotes;
```

**`GovernorVotes`**: 
- Extension of {Governor} for voting weight extraction from an {ERC20Votes} token, or since v4.5 an {ERC721Votes} token.

**`GovernorVotesQuorumFraction`**: 
- Extension of {Governor} for voting weight extraction from an {ERC20Votes} token and a quorum expressed as a fraction of the total supply.

**`GovernorTimelockControl`**: 
- Extension of {Governor} that binds the execution process to an instance of {TimelockController}. This adds a delay, enforced by the {TimelockController} to all successful proposal (in addition to the voting duration). The {Governor} needs the proposer (and ideally the executor and canceller) roles for the {Governor} to work properly.
-  Using this model means the proposal will be operated by the {TimelockController} and not by the {Governor}. Thus, the assets and permissions must be attached to the {TimelockController}. Any asset sent to the {Governor} will be inaccessible from a proposal, unless executed via {Governor-relay}.
-  WARNING: Setting up the TimelockController to have additional proposers or cancellers besides the governor is very risky, as it grants them the ability to: 1) execute operations as the timelock, and thus possibly performing operations or accessing funds that are expected to only be accessible through a vote, and 2) block governance proposals that have been approved by the voters, effectively executing a Denial of Service attack.

**`TimeLock.sol`**
```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;


import {TimelockController} from "@openzeppelin/contracts/governance/extensions/GovernorTimelockControl.sol";

contract TimeLock is TimelockController {
    // minDelay is how long you have to wait before executing
    // proposers is the list of addresses that can propose
    // executors is the list of addresses that can execute
    constructor(uint256 minDelay, address[] memory proposers, address[] memory executors)
        TimelockController(minDelay, proposers, executors, msg.sender)
    {}
}
```
- When we create a proposal, our `Governor` contract will be communicating with the `TimeLock` contract

#### Testing the governance smart contract
Setup our test `MyGovernorTest.t.sol`
```solidity
// SPDX-License-Identifier: SEE LICENSE IN LICENSE
pragma solidity ^0.8.4;

import {Test} from "forge-std/Test.sol";
import {MyGovernor} from "../src/MyGovernor.sol";
import {Box} from "../src/Box.sol";
import {GovToken} from "../src/GovToken.sol";
import {TimeLock} from "../src/TimeLock.sol";

contract MyGovernorTest is Test {
    function setUp() public {
    }
}
```

For this project, we're adding a mint function to our `GovToken` contract, but this isn't something we would want to do in a real project (allow anyone to mint)
```solidity
function mint(address to, uint256 amount) public {
	_mint(to, amount);
}
```

We continue with the `setUp` function:
```solidity
 function setUp() public {
        govToken = new GovToken();
        govToken.mint(USER, INITIAL_SUPPLY);

        vm.startPrank(USER);
        govToken.delegate(USER);
        timelock = new TimeLock(MIN_DELAY, proposers, executors);
        governor = new MyGovernor(govToken, timelock);

        bytes32 proposerRole = timelock.PROPOSER_ROLE();
        bytes32 executorRole = timelock.EXECUTOR_ROLE();
        bytes32 adminRole = timelock.DEFAULT_ADMIN_ROLE();

        timelock.grantRole(proposerRole, address(governor));
        timelock.grantRole(executorRole, address(0));
        timelock.revokeRole(adminRole, USER);
        vm.stopPrank();
        
        box = new Box();
        box.transferOwnership(address(timelock));
    }
```
- we create a user and grant the user an initial supply, and delegate to the user
- we deploy the various contracts with the necessary arguments
- we set roles
	- the governor is the proposer
	- anyone can be executor
	- revoke the admin role from the user
- create a new `box` and transfer ownership to `timelock`

Our first test to make sure everything compiles and ensuring we can't update the box unless it's through governance
```solidity
function testCantUpdateBoxWithoutGovernance() public {
	vm.expectRevert();
	box.store(1);
}
```


```solidity
function testGovernanceUpdatesBox() public {
        uint256 valueToStore = 888;
        string memory description = "store 1 in box";
        bytes memory encodedFunctionCall = abi.encodeWithSignature("store(uint256)", valueToStore);

        values.push(0);
        calldatas.push(encodedFunctionCall);
        targets.push(address(box));

        // 1. Propose to DAO
        uint256 proposalId = governor.propose(targets, values, calldatas, description);
        // View the state, should be 0
        console.log("Proposal state: ", uint256(governor.state(proposalId)));
        vm.warp(block.timestamp + VOTING_DELAY + 1);
        vm.roll(block.number + VOTING_DELAY + 1);
        // State should now be active
        console.log("Proposal state: ", uint256(governor.state(proposalId)));

        // 2. Vote
        string memory reason = "reasons";
        uint8 voteWay = 1; // votting yes

        vm.prank(USER);
        governor.castVoteWithReason(proposalId, voteWay, reason);

        vm.warp(block.timestamp + VOTING_PERIOD + 1);
        vm.roll(block.number + VOTING_PERIOD + 1);

        // 3. Queue the TX
        bytes32 descriptionHash = keccak256(abi.encodePacked(description));
        governor.queue(targets, values, calldatas, descriptionHash);

        vm.warp(block.timestamp + MIN_DELAY + 1);
        vm.roll(block.number + MIN_DELAY + 1);

        // 4. Execute the tx
        governor.execute(targets, values, calldatas, descriptionHash);
        assert(box.getNumber() == valueToStore);
    }
```
- shows us the exact process of how a DAO actually works

### [Lesson 15 Security and Auditing](https://www.youtube.com/watch?v=wUjYK5gwNZs&t=26472s)
#### Intro
- [Readiness checklist](https://github.com/nascentxyz/simple-security-toolkit)
- Total value stolen in crypto hacks for 2022 was 3.8 billion
	- That is about 6% of the defi TVL
- [rekt leaderboard](https://rekt.news/leaderboard/)
	- as of April 2024, the top 3 were unaudited

#### What is a smart contract audit
- A smart contract is time boxed, security based code review
- An auditor's goal is to find as many security vulnerabilities as possible and educate the protocol on security best practices
- Auditors use a combination of manual reviews and automated tools
- Because smart contracts are immutable, once a smart contract is deployed, they can't be changed
- Blockchains are adversarial by nature, so malicious actors will always be looking to exploit
- Audits can
	- improve developer teams understanding of code
	- improve speed and effectiveness
	- improve developer effectiveness
	- teach the latest tooling
- One audit usually isn't enough, there are many options
	- Formal verification
	- Competitive audits
	- Bug Bounty Programs
- There are many companies that perform audits as well as independent auditors
- The Audit Process
	1. Price and Timeline: protocols can reach out before or after code is finished
		- will discuss how long audit will take based on: code complexity, scope, duration, timeline
- Scope: The code that will be audited
- Lines of code: duration
	- 100: 2.5 days
	- 500: 1 week
	- 1000: 1-2 weeks
	- 2500: 2-3 weeks
	- 5000: 3-5 weeks
	- 5000+: 5+ weeks
- Commit hash, start date, down payment
	- once we have a commit hash, we can finalize start date and final price
	- commit hash is the unique id of the codebase
	- some auditors ask for a down payment before audit begins
- Audit begins
	- auditors will use every tool in their arsenal to find vulnerabilities
- Initial report
	- After the time period ends, auditors will give an initial report
	- all findings listed by severity: high, medium, low, informational/non critical, gas efficiencies
	- High/medium/low represent the severity of impact and likelihood of each vulnerability
	- Information/gas/non-critical are findings to improve efficiency of code 
- Mitigation begins
	- agreed upon time to fix vulnerabilities found in initial audit report
- Final report
	- another audit focused exclusively on changes after mitigation fixes
- For developers
	1. Have clear documentation
	2. Robust test suite ideally including fuzz tests
	3. Code should be commented and readable
	4. Modern best practices followed
	5. Established communication channel between auditors and developers
	6. Do an initial video walkthrough of code before audit starts
- Have a dedicated channel where auditors can ask developers questions
- 80% of all bugs are business logic implementation bugs
	- These bugs have nothing to do with a coding error, but somebody not knowing what the protocol should be doing
- Post audit
	- making changes after an audit makes it unaudited code
- What an audit isn't
	- An audit doesn't mean that code is bug free
	- An audit is a security journey to find as many bugs as possible
	- A continuous process that is always evolving

#### Top security tools
**Security is for both protocol devs and auditors**

- Smart contract devs should know all the tools and use them before going to audit  

- [Solcurity](https://www.alchemy.com/dapps/solcurity)
	- A security-conscious list of standards compiled from the work by experts including Mudit Gupta, and organizations like ConsenSys Diligence, BoringCrypto, and Runtime Verification. 
	- Smart contract developers can learn how to approach sensitive data handling code using best practice methods and checks. 
	- Over a hundred such advice points ranging from event calls, contract structure, and DeFi-specific standards are available.

- [Simple security toolkit](https://github.com/nascentxyz/simple-security-toolkit)
	- This repo is a collection of practical security-focused guides and checklists for smart contract development, assembled by the [Nascent](https://www.nascent.xyz/) team to share with our portfolio companies and others in the ecosystem who might find it useful. 
	- It is not intended to be comprehensive; it skews towards practical and opinionated recommendations that we find to be appropriate particularly for teams developing and managing early versions of a protocol.

- The audit process
	- There is no silver bullet, BUT...
	- Manual review:
		- go through code and docs
		- understand what the protocol should do
	- Using tools

- Manual review, example code:
```solidity
contract CaughtWithTest {
	uint256 public number;

	function setNumber(uint256 newNumber) public {
		number = newNumber + 1;
	}
}
```
- There is nothing wrong with this code
- BUT, if we read the docs and it says this function should be doing something else, then this code is wrong
- So we need to understand what the protocol should be doing

- Using tools: 
	- Test Suites:
		- Hardhat
		- Foundry
		- etc
	- Static analysis:
		- automatically checking code for issues without executing anything... hence the debugging is static
		- Slither
		- 4nalyzer
		- Mythril (also symbolic execution)
		- most of these tools just "dumbly" look for keywords in specific orders
	- Fuzz testing:
		- provide random data as inputs during testing
		- stateful fuzz testing: fuzz testing, but the system remembers the state of the last fuzz test and continues with the new fuzz test
	- Differential test
		- a way to write the same code multiple times
	- Formal verification:
		- A generic term for applying formal methods (FM) to verify the correctness of hardware
		- applying FM means anything based on mathematical proofs, in software often used as a proof of correctness or proof of "bug"
		- mathematically proving that something in your code can happen
	- Symbolic execution:
		- A form of FV where you convert software to a mathematical expression
		- Take your solidity function and convert it to math, which can be solved and provide us a right and wrong context
		- Very time intensive and a lot of protocols and audit firms don't go down this route
	- AI Tools:
		- They are not very good yet

#### Introduction to manual review
- Step 1:
	- download the code
	- read the docs

- Step 2:
	- bring and use the tools that you're most familiar with

- `clock`: command line utility that helps count lines of code

- Step 3:
	- get an overview of what you're auditing
	- rank contracts based on complexity (lines of code)
	- when you start auditing contracts, label them as: `Not Started`, `In Progress`, `Done`

- Step 4: 
	- take notes
	- leave notes in the code (questions, issues, checkpoints)
	- have a dedicated file for notes where you can dump ideas

- Step 5: 
	- be aware of rabbit holes, and know when to jump
	- we will have to research topics, but don't lose sight of the big picture

- Step 6:
	- use tools to validate issues that come up
	- use fuzz tests to make sure functions do what they're supposed to do

- Step 7:
	- have communication with the developers and ask questions about doubts

- Step 8:
	- create time bounds
	- you can go through code forever and keep thinking of attacks, so set a time limit

- Step 9:
	- wrap up by writing a good report
	- 50% analysis and 50% readable report
	- when fixes are made, we have to make sure new bugs haven't been introduced

#### Introduction to Formal Verification
- Formal verification is the act of proving or disproving a given property of a system using a mathematical model
- Symbolic execution is one technique used for formal verification using a mathematical model
	- explores different paths in a program, creating a mathematical representation for each path
	- converts our code to a set of mathematical expressions

- Layer 1: unit test
	- look at specific functions
	- the bare minimum
- Layer 2: fuzz test
	- fuzzing is when you take random inputs and run them through your program
	- you have to define things in your code you always want to hold true
	- the new bare minimum
- Layer 3: static analysis
	- dynamic testing (like unit and fuzz) involves running code
	- static analysis involves looking at our code, having a tool look at our code
	- slither and the solidity compiler can be used for static analysis
- Layer 4: formal verification
	- the act of proving or disproving a given property in the system
	- done through a mathematical model of the system and the property

- Fuzz testing tries to break properties by throwing random data at your system
- Formal verification tries to break properties using mathematical proofs

- Some techniques for formal verification
	- symbolic execution
	- abstract interpretation
	- model checking

- Symbolic execution involves exploring the different paths of the program and for each execution path, creating a mathematical representation

- [smt-lib](https://smtlib.github.io/jSMTLIB/SMTLIBTutorial.pdf) is a language made specifically for solvers

- path explosion problem: too many paths for a computer to explore in a reasonable amount of time

- [secure contract](https://secure-contracts.com)