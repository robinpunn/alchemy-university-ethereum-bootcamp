## Fetch Token Transfers

---

### Table of Contents
1. [Fetching Token Transfers](#fetching-token-transfers)
1. [API Key](#api-key)
    - [Alchemy API Key](#alchemy-api-key)
    - [Your Goal: Fetch the Key](#your-goal-fetch-the-key)
1. [First Topic](#first-topic)
    - [Topics](#topics)
    - [Your Goal: Our First Topic](#your-goal-our-first-topic)
1. [Second Topic](#second-topic)
    - [Indexed Topics](#indexed-topics)
    - [Your Goal: Indexed From](#your-goal-indexed-from)
1.  [Total Dai](#total-dai)
    - [Get Logs](#get-logs)
    - [Your Goal: Total Dai Transferred](#your-goal-total-dai-transferred)
1. [Transfers API](#transfers-api)
    - [Your Goal: Use the Transfers API](#your-goal-use-the-transfers-api)


---

### Fetching Token Transfers
- Hey there! Let's take a moment to focus on events, specifically the Transfer event!
- As you're building decentralized applications, you'll quickly discover how important it is to be able to retrieve token data for specific users. 
- Whether you're building a wallet, an exchange, or just about any other web3 application, you'll need a fast and efficient way to retrieve this data so you can provide your users with the best possible experience.
- We'll start with the [eth_getLogs](https://docs.alchemy.com/reference/eth-getlogs) endpoint and then we'll dive into the [Alchemy Transfers API](https://docs.alchemy.com/reference/alchemy-getassettransfers). 
- The Transfers API allows you to retrieve token transfers pertaining to specific users quickly and easily, without having to sift through vast amounts of data or build your own indexing and searching infrastructure.
- In this code lesson, we'll explore both of these methods for retrieving historical token transfers in depth, so you can understand on a fundamental level how they work and why they're so essential to building great web3 applications.

### API Key
#### Alchemy API Key
- In this exercise, you'll need to grab your Alchemy API Key so you can start making some JSON RPC Requests!
> An API key is a unique identifier that grants access to an API (Application Programming Interface). It acts as a secret token that allows the user to gain access to a set of methods.
- When using your Alchemy API key, it's important to keep it safe and secure, so only your code can access your Alchemy Apps. 
    - For that reason, we'll be putting it in ``.env`` file. The ``.env`` file is a configuration file that is used to store environment variables in a project. 
    - Sometimes, these variables are sensitive and should not be kept with the source code of the project. 
    - Other times, they are simply variables that are different depending on the environment you're in (i.e. your local environment vs production).
> We'll be making use of the [dotenv](https://www.npmjs.com/package/dotenv) module to load our environment variables. We recommend you follow this same practice in your own projects!
- The format of a .env file is:
```bash
KEY1=VALUE1
KEY2=VALUE2
```
- Often times you'll see the values in quotes. 
    - This is only necessary if your value has a space in it like "my value". 
    - Whitespace surrounding the value is not an issue in a .env file.

#### Your Goal: Fetch the key! 
- The goal of this stage is to fill in the .env file with your Alchemy API Key! When you do so, the test cases will attempt to make a request to your Alchemy endpoint. If it's successful, you'll pass the test cases! You'll need to
    1. Visit the Alchemy Dashboard. If it's your first time visiting the dashboard, you'll need to go through a sign up flow.
    1. Once you're on the dashboard page, you'll need a mainnet app. If you don't have one, click "+Create App". Choose Ethereum as your Chain and Mainnet as your Network.
    1. Click "View Key" on your Mainnet App and copy the API Key. Paste it into your .env as the value for the API_KEY.
    1. Once you've pasted the API Key, run your code!

### First Topic
#### Topics
- In the upcoming stages, we'll use the eth_getLogs JSON RPC endpoint (docs here) to retrieve the logs related to the Dai contract. 
    - We'll use this determine the total amount of DAI transfered by a particular address. 
    - Before we get there we need to talk about topics! 
    - Topics are used to categorize the logs to search for specific events! But, what are topics, exactly?
- Topics are 32-byte hash values that represent a specific piece of information related to the event being logged. 
    - For example, if a smart contract logs an event every time a user makes a purchase, one topic might represent the user's address, while another topic might represent the product that was purchased.
- Topics are used to filter and sort log entries, which makes it easier for developers and users to analyze the data generated by smart contracts.

#### Your Goal: Our First Topic
- If we want to filter for Transfer events, we'll need to provide eth_getLogs with the topic to search for. 
    - The first topic is the event signature. 
    - We'll need to take the Transfer event, strip all of the keywords, spaces and argument names, and finally keccak hash it to get the topic representing the transfer event.
- You can find the standard Transfer event [here](https://eips.ethereum.org/EIPS/eip-20#events), which is defined as:
```solidity
event Transfer(address indexed _from, address indexed _to, uint256 _value)
```
- Your goal is to complete TODO #1:
1. Take the above ``Transfer`` event signature, strip the keywords (``event``, ``indexed`` but not the types!), spaces and argument names.
1. Put the resulting stripped down signature in the ``eventSignature`` variable.
> Hint: For a similar example, a stripped down purchase signature might look like this: ``Purchased(address,uint256)``. Notice there are no spaces! Parenthesis and commas are preserved.
- That's it! This method is setup to keccak hash the signature for you, so the topic will be made available to our ``eth_getLogs`` call which we'll work on in a future stage!
> Hopefully this process of hashing the signature should feel a bit familiar! This is similar to how we target function signatures on smart contracts, by hashing the function signature and adding the first 4 bytes to the calldata of the transaction!

----

**SOLUTION**
```js
const { keccak256 } = require("ethereum-cryptography/keccak");
const { toHex, utf8ToBytes } = require("ethereum-cryptography/utils");

function firstTopic() {
    const eventSignature = "Transfer(address,address,uint256)"; // <-- TODO #1: fill in the event signature!
    const bytes = utf8ToBytes(eventSignature);
    const digest = keccak256(bytes);
    return toHex(digest);
}

function secondTopic() {
    // TODO #2: add the address and left-pad it with zeroes to 32 bytes
    // then return the value
    const address = "";
}

module.exports = { firstTopic, secondTopic }
```

---

### Second Topic
#### Indexed Topics
- In the last stage you may have noticed the word "indexed" in the event signature:
```js
event Transfer(address indexed _from, address indexed _to, uint256 _value)
```
- When a topic is marked as "indexed", it means that the Ethereum Virtual Machine will hash the topic's value before storing it in the log entry.
    - This allows the Ethereum client software to efficiently search for log entries based on the values of indexed topics.
- Indexed topics can be used to filter and sort log entries based on specific criteria, such as the address of the sender, the type of event that occurred, or other important information.
    - This makes it easier for developers and users to analyze the data generated by smart contracts and to identify specific events of interest.
- When it comes to topics, the first topic is the event signature.
    - The second, third and fourth topics (there's a max of 4 topics) are each indexed parameter in the order they are defined.
#### Your Goal: Indexed From
- Let's focus on ``TODO #2`` and fill out the ``secondTopic`` function! For our second topic, we're going to specify the ``_from`` address in the ``Transfer`` event. This way, we can filter on who sent the token.
- To do this, we'll need to take an address and pad it out to 32 bytes. The address we're going to use is a super active one on mainnet.
1. Copy the following address: 0x28c6c06298d514db089934071355e5743bf21d60
1. Paste it into a string in the secondTopic function.
1. Strip the leading 0x out of the address.
1. Pad this address out to 32 bytes by adding zeroes in front of the address.

----

**SOLUTION**
```js
const { keccak256 } = require("ethereum-cryptography/keccak");
const { toHex, utf8ToBytes } = require("ethereum-cryptography/utils");

function firstTopic() {
    const eventSignature = "Transfer(address,address,uint256)"; // <-- TODO #1: fill in the event signature!
    const bytes = utf8ToBytes(eventSignature);
    const digest = keccak256(bytes);
    return toHex(digest);
}

function secondTopic() {
    // TODO #2: add the address and left-pad it with zeroes to 32 bytes
    // then return the value
    const address = "28c6c06298d514db089934071355e5743bf21d60";
    return "0".repeat(24) + address;
}

module.exports = { firstTopic, secondTopic }
```

---

### Total Dai
#### Get Logs
- Ok, now it's time to use the ``eth_getLogs`` endpoint!
    - This method is part of the Ethereum JSON-RPC API standard.
    - It allows clients to retrieve a list of log entries that match a specified set of filter criteria.
    - In the last two stages we have set our filter criteria by building the first two topics!
- When a smart contract emits an event, it generates a log entry that contains information about the event.
    - The ``eth_getLogs`` endpoint allows clients to retrieve a list of these log entries!
    - The request params are essentially a filter object that specifies the criteria for the log entries to be retrieved.
    - The filter object can include fields such as contract address, topics, fromBlock, and toBlock, among others (see the [full documentation here](https://docs.alchemy.com/reference/eth-getlogs)).
- This ``eth_getLogs`` endpoint can be useful for developers and users who want to analyze the data generated by smart contracts and track specific events of interest.
    - In our example we are filtering on the Transfer event, but we could be filtering for any type of event with any of the indexed parameters!
- When you retrieve the logs from the eth_getLogs endpoint, each log will have a data property which is a string that contains the concatenated values of all non-indexed arguments.
    - Each non-indexed argument is padded to 32 bytes, similar to what we did with the second topic!
    - In the case of the Transfer event, there is only one non-indexed value.

#### Your Goal: Total Dai Transferred
- Let's get all the dai transferred from the account we padded in stage two, between the ``fromBlock`` and the ``toBlock`` using the ``eth_getLogs`` method through the [Alchemy SDK](https://docs.alchemy.com/reference/alchemy-sdk-quickstart)!
- Take a look at the ``eth_getLogs`` documentation to learn what the names of the parameters are to provide them to the ``params`` object.
    - Then, you'll need to take a look at the response to return the sum of all the dai transfered across all of the logs.
    - Let's break this out into steps:
    1. The ``toBlock``, ``fromBlock``, and ``topics`` (which you manually encoded!) are all already provided to the params.
        - You'll just need to add the ``address`` for the contract we're looking for events on, which is the dai contract: ``0x6b175474e89094c44da98b954eedeac495271d0f``
    2. Find which property in each log holds the total amount of dai transferred by looking at the [eth_getLogs documentation](https://docs.alchemy.com/reference/eth-getlogs) or inspecting the response with ``console.log``.
    3. Sum up all of the dai transferred across all the logs and return it.
        - You will need to use ``BigInt`` here because we're going to be working with very large numbers.
        - You can find the [BigInt documentation on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt).
    4. Return the sum of all the dai transferred.
> Hint: When you're looking for the amount of dai transferred in each log, it's important to note that the property data is going to all of the non-indexed parameters in the event. And remember the transfer event signature is event Transfer(address indexed _from, address indexed _to, uint256 _value).

---
**SOLUTIONS**

```js
// topics.js
const { keccak256 } = require("ethereum-cryptography/keccak");
const { toHex, utf8ToBytes } = require("ethereum-cryptography/utils");

function firstTopic() {
    const eventSignature = "Transfer(address,address,uint256)"; // <-- TODO #1: fill in the event signature!
    const bytes = utf8ToBytes(eventSignature);
    const digest = keccak256(bytes);
    return toHex(digest);
}

function secondTopic() {
    // TODO #2: add the address and left-pad it with zeroes to 32 bytes
    // then return the value
    const address = "28c6c06298d514db089934071355e5743bf21d60";
    return "0".repeat(24) + address;
}

module.exports = { firstTopic, secondTopic }

//totalDaiTransferred.js
require("dotenv").config();
const { Alchemy, Network } = require("alchemy-sdk");
const { firstTopic, secondTopic } = require('./topics');
// prefix both the topics with 0x
const topics = [firstTopic(), secondTopic()].map((x) => '0x' + x);

const config = {
    apiKey: process.env.API_KEY,
    network: Network.ETH_MAINNET,
};

const alchemy = new Alchemy(config);

async function totalDaiTransferred(fromBlock, toBlock) {
    const logs = await alchemy.core.getLogs({
        address: "0x6b175474e89094c44da98b954eedeac495271d0f", // <-- TODO #1: fill in the dai address here
        fromBlock,
        toBlock,
        topics
    });

    // take a look at the first log in the response
    // console.log(BigInt(logs[0].data));
    return logs.map(dai=> BigInt(dai.data)).reduce((acc,ind)=>acc+ind)
    // <-- TODO #2: return the total dai transferred during this timeframe
}

module.exports = totalDaiTransferred;
```

---

### Transfers API
- Are you thinking to yourself that ``eth_getLogs`` seems complicated to use?
    - It probably seems like quite a generic method.
    - When you think about it from the protocol's perspective this makes sense!
    - The underlying protocol knows nothing about EIP standards, so it's not aware of things like NFTs and ERC20s.
    - Fortunately, at Alchemy we've built a tool specifically for this use case: the [Alchemy Transfers API](https://docs.alchemy.com/reference/alchemy-getassettransfers).
- The Alchemy Transfers API is a powerful tool that makes it easy for developers to fetch historical transaction data for any address.
    - It's a fast and efficient alternative to scanning the entire blockchain, so you can focus on building great user experiences without having to worry about the technical details.

#### Your Goal: Use the Transfers API
- Ok, we admit it!
    - We've been eagerly awaiting this stage.
    - It's time for you to try the Transfers API yourself with the Alchemy SDK!
    - We want you to return the total number of ERC20 transfers (any ERC20 token) that a specific address made between fromBlock and toBlock.
    - This sort of query is super easy to make with the getAssetTransfers method!
1. Take a look at the [getAssetTransfers](https://docs.alchemy.com/reference/alchemy-getassettransfers) documentation to see the params we can send through.
1. For the ``fromAddress`` let's use the same address we used in the previous stage: ``0x28c6c06298d514db089934071355e5743bf21d60``.
1. For the ``category`` we'll provide ``'erc20'`` as the only category.
1. Lastly, inspect the response with ``console.log``. Find out the total number of transfers for this time period and return that number.
- That's it! Much simpler than hashing topics in eth_getLogs, huh?
    - And we're doing this for all ERC20 contracts, wow!
    - That's just a taste of the power of the Transfers API.
    - What kind of awesome user experiences could you build with this API?

---

**SOLUTION**
```js
require("dotenv").config();
const { Alchemy, Network } = require("alchemy-sdk");

const config = {
    apiKey: process.env.API_KEY,
    network: Network.ETH_MAINNET,
};

const alchemy = new Alchemy(config);

async function totalErc20Transfers(fromBlock, toBlock) {
    const res = await alchemy.core.getAssetTransfers({
        fromBlock,
        toBlock,
        fromAddress: "0x28c6c06298d514db089934071355e5743bf21d60", // <-- TODO: fill this in
        category: ['erc20'], // <-- TODO: fill this in
    });

    // inspect the response to see all the transfers
    console.log(res.transfers.length);

    // TODO: return the total number of ERC20 transfers
    return res.transfers.length
}

module.exports = totalErc20Transfers;
```

---